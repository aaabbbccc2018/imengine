// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: privacy.proto

#ifndef PROTOBUF_privacy_2eproto__INCLUDED
#define PROTOBUF_privacy_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "peers.pb.h"
// @@protoc_insertion_point(includes)

namespace zproto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_privacy_2eproto();
void protobuf_InitDefaults_privacy_2eproto();
void protobuf_AssignDesc_privacy_2eproto();
void protobuf_ShutdownFile_privacy_2eproto();

class BlockUserReq;
class LoadBlockedUsersReq;
class LoadBlockedUsersRsp;
class UnblockUserReq;
class UserBlockedNotify;
class UserUnblockedNotify;

// ===================================================================

class BlockUserReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.BlockUserReq) */ {
 public:
  BlockUserReq();
  virtual ~BlockUserReq();

  BlockUserReq(const BlockUserReq& from);

  inline BlockUserReq& operator=(const BlockUserReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockUserReq& default_instance();

  static const BlockUserReq* internal_default_instance();

  void Swap(BlockUserReq* other);

  // implements Message ----------------------------------------------

  inline BlockUserReq* New() const { return New(NULL); }

  BlockUserReq* New(::google::protobuf::Arena* arena) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BlockUserReq* other);
  void UnsafeMergeFrom(const BlockUserReq& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .zproto.UserOutPeer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::zproto::UserOutPeer& peer() const;
  ::zproto::UserOutPeer* mutable_peer();
  ::zproto::UserOutPeer* release_peer();
  void set_allocated_peer(::zproto::UserOutPeer* peer);

  // @@protoc_insertion_point(class_scope:zproto.BlockUserReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::zproto::UserOutPeer* peer_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_privacy_2eproto_impl();
  friend void  protobuf_AddDesc_privacy_2eproto_impl();
  friend void protobuf_AssignDesc_privacy_2eproto();
  friend void protobuf_ShutdownFile_privacy_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<BlockUserReq> BlockUserReq_default_instance_;

// -------------------------------------------------------------------

class UnblockUserReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.UnblockUserReq) */ {
 public:
  UnblockUserReq();
  virtual ~UnblockUserReq();

  UnblockUserReq(const UnblockUserReq& from);

  inline UnblockUserReq& operator=(const UnblockUserReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnblockUserReq& default_instance();

  static const UnblockUserReq* internal_default_instance();

  void Swap(UnblockUserReq* other);

  // implements Message ----------------------------------------------

  inline UnblockUserReq* New() const { return New(NULL); }

  UnblockUserReq* New(::google::protobuf::Arena* arena) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnblockUserReq* other);
  void UnsafeMergeFrom(const UnblockUserReq& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .zproto.UserOutPeer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::zproto::UserOutPeer& peer() const;
  ::zproto::UserOutPeer* mutable_peer();
  ::zproto::UserOutPeer* release_peer();
  void set_allocated_peer(::zproto::UserOutPeer* peer);

  // @@protoc_insertion_point(class_scope:zproto.UnblockUserReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::zproto::UserOutPeer* peer_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_privacy_2eproto_impl();
  friend void  protobuf_AddDesc_privacy_2eproto_impl();
  friend void protobuf_AssignDesc_privacy_2eproto();
  friend void protobuf_ShutdownFile_privacy_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<UnblockUserReq> UnblockUserReq_default_instance_;

// -------------------------------------------------------------------

class LoadBlockedUsersReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.LoadBlockedUsersReq) */ {
 public:
  LoadBlockedUsersReq();
  virtual ~LoadBlockedUsersReq();

  LoadBlockedUsersReq(const LoadBlockedUsersReq& from);

  inline LoadBlockedUsersReq& operator=(const LoadBlockedUsersReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadBlockedUsersReq& default_instance();

  static const LoadBlockedUsersReq* internal_default_instance();

  void Swap(LoadBlockedUsersReq* other);

  // implements Message ----------------------------------------------

  inline LoadBlockedUsersReq* New() const { return New(NULL); }

  LoadBlockedUsersReq* New(::google::protobuf::Arena* arena) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoadBlockedUsersReq* other);
  void UnsafeMergeFrom(const LoadBlockedUsersReq& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zproto.LoadBlockedUsersReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_privacy_2eproto_impl();
  friend void  protobuf_AddDesc_privacy_2eproto_impl();
  friend void protobuf_AssignDesc_privacy_2eproto();
  friend void protobuf_ShutdownFile_privacy_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<LoadBlockedUsersReq> LoadBlockedUsersReq_default_instance_;

// -------------------------------------------------------------------

class LoadBlockedUsersRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.LoadBlockedUsersRsp) */ {
 public:
  LoadBlockedUsersRsp();
  virtual ~LoadBlockedUsersRsp();

  LoadBlockedUsersRsp(const LoadBlockedUsersRsp& from);

  inline LoadBlockedUsersRsp& operator=(const LoadBlockedUsersRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadBlockedUsersRsp& default_instance();

  static const LoadBlockedUsersRsp* internal_default_instance();

  void Swap(LoadBlockedUsersRsp* other);

  // implements Message ----------------------------------------------

  inline LoadBlockedUsersRsp* New() const { return New(NULL); }

  LoadBlockedUsersRsp* New(::google::protobuf::Arena* arena) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoadBlockedUsersRsp* other);
  void UnsafeMergeFrom(const LoadBlockedUsersRsp& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zproto.UserOutPeer user_peers = 1;
  int user_peers_size() const;
  void clear_user_peers();
  static const int kUserPeersFieldNumber = 1;
  const ::zproto::UserOutPeer& user_peers(int index) const;
  ::zproto::UserOutPeer* mutable_user_peers(int index);
  ::zproto::UserOutPeer* add_user_peers();
  ::google::protobuf::RepeatedPtrField< ::zproto::UserOutPeer >*
      mutable_user_peers();
  const ::google::protobuf::RepeatedPtrField< ::zproto::UserOutPeer >&
      user_peers() const;

  // @@protoc_insertion_point(class_scope:zproto.LoadBlockedUsersRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::zproto::UserOutPeer > user_peers_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_privacy_2eproto_impl();
  friend void  protobuf_AddDesc_privacy_2eproto_impl();
  friend void protobuf_AssignDesc_privacy_2eproto();
  friend void protobuf_ShutdownFile_privacy_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<LoadBlockedUsersRsp> LoadBlockedUsersRsp_default_instance_;

// -------------------------------------------------------------------

class UserBlockedNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.UserBlockedNotify) */ {
 public:
  UserBlockedNotify();
  virtual ~UserBlockedNotify();

  UserBlockedNotify(const UserBlockedNotify& from);

  inline UserBlockedNotify& operator=(const UserBlockedNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserBlockedNotify& default_instance();

  static const UserBlockedNotify* internal_default_instance();

  void Swap(UserBlockedNotify* other);

  // implements Message ----------------------------------------------

  inline UserBlockedNotify* New() const { return New(NULL); }

  UserBlockedNotify* New(::google::protobuf::Arena* arena) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserBlockedNotify* other);
  void UnsafeMergeFrom(const UserBlockedNotify& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 uid = 1;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  ::google::protobuf::int32 uid() const;
  void set_uid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zproto.UserBlockedNotify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 uid_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_privacy_2eproto_impl();
  friend void  protobuf_AddDesc_privacy_2eproto_impl();
  friend void protobuf_AssignDesc_privacy_2eproto();
  friend void protobuf_ShutdownFile_privacy_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<UserBlockedNotify> UserBlockedNotify_default_instance_;

// -------------------------------------------------------------------

class UserUnblockedNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.UserUnblockedNotify) */ {
 public:
  UserUnblockedNotify();
  virtual ~UserUnblockedNotify();

  UserUnblockedNotify(const UserUnblockedNotify& from);

  inline UserUnblockedNotify& operator=(const UserUnblockedNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserUnblockedNotify& default_instance();

  static const UserUnblockedNotify* internal_default_instance();

  void Swap(UserUnblockedNotify* other);

  // implements Message ----------------------------------------------

  inline UserUnblockedNotify* New() const { return New(NULL); }

  UserUnblockedNotify* New(::google::protobuf::Arena* arena) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserUnblockedNotify* other);
  void UnsafeMergeFrom(const UserUnblockedNotify& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 uid = 1;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  ::google::protobuf::int32 uid() const;
  void set_uid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zproto.UserUnblockedNotify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 uid_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_privacy_2eproto_impl();
  friend void  protobuf_AddDesc_privacy_2eproto_impl();
  friend void protobuf_AssignDesc_privacy_2eproto();
  friend void protobuf_ShutdownFile_privacy_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<UserUnblockedNotify> UserUnblockedNotify_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// BlockUserReq

// optional .zproto.UserOutPeer peer = 1;
inline bool BlockUserReq::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline void BlockUserReq::clear_peer() {
  if (GetArenaNoVirtual() == NULL && peer_ != NULL) delete peer_;
  peer_ = NULL;
}
inline const ::zproto::UserOutPeer& BlockUserReq::peer() const {
  // @@protoc_insertion_point(field_get:zproto.BlockUserReq.peer)
  return peer_ != NULL ? *peer_
                         : *::zproto::UserOutPeer::internal_default_instance();
}
inline ::zproto::UserOutPeer* BlockUserReq::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::zproto::UserOutPeer;
  }
  // @@protoc_insertion_point(field_mutable:zproto.BlockUserReq.peer)
  return peer_;
}
inline ::zproto::UserOutPeer* BlockUserReq::release_peer() {
  // @@protoc_insertion_point(field_release:zproto.BlockUserReq.peer)
  
  ::zproto::UserOutPeer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline void BlockUserReq::set_allocated_peer(::zproto::UserOutPeer* peer) {
  delete peer_;
  peer_ = peer;
  if (peer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:zproto.BlockUserReq.peer)
}

inline const BlockUserReq* BlockUserReq::internal_default_instance() {
  return &BlockUserReq_default_instance_.get();
}
// -------------------------------------------------------------------

// UnblockUserReq

// optional .zproto.UserOutPeer peer = 1;
inline bool UnblockUserReq::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline void UnblockUserReq::clear_peer() {
  if (GetArenaNoVirtual() == NULL && peer_ != NULL) delete peer_;
  peer_ = NULL;
}
inline const ::zproto::UserOutPeer& UnblockUserReq::peer() const {
  // @@protoc_insertion_point(field_get:zproto.UnblockUserReq.peer)
  return peer_ != NULL ? *peer_
                         : *::zproto::UserOutPeer::internal_default_instance();
}
inline ::zproto::UserOutPeer* UnblockUserReq::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::zproto::UserOutPeer;
  }
  // @@protoc_insertion_point(field_mutable:zproto.UnblockUserReq.peer)
  return peer_;
}
inline ::zproto::UserOutPeer* UnblockUserReq::release_peer() {
  // @@protoc_insertion_point(field_release:zproto.UnblockUserReq.peer)
  
  ::zproto::UserOutPeer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline void UnblockUserReq::set_allocated_peer(::zproto::UserOutPeer* peer) {
  delete peer_;
  peer_ = peer;
  if (peer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:zproto.UnblockUserReq.peer)
}

inline const UnblockUserReq* UnblockUserReq::internal_default_instance() {
  return &UnblockUserReq_default_instance_.get();
}
// -------------------------------------------------------------------

// LoadBlockedUsersReq

inline const LoadBlockedUsersReq* LoadBlockedUsersReq::internal_default_instance() {
  return &LoadBlockedUsersReq_default_instance_.get();
}
// -------------------------------------------------------------------

// LoadBlockedUsersRsp

// repeated .zproto.UserOutPeer user_peers = 1;
inline int LoadBlockedUsersRsp::user_peers_size() const {
  return user_peers_.size();
}
inline void LoadBlockedUsersRsp::clear_user_peers() {
  user_peers_.Clear();
}
inline const ::zproto::UserOutPeer& LoadBlockedUsersRsp::user_peers(int index) const {
  // @@protoc_insertion_point(field_get:zproto.LoadBlockedUsersRsp.user_peers)
  return user_peers_.Get(index);
}
inline ::zproto::UserOutPeer* LoadBlockedUsersRsp::mutable_user_peers(int index) {
  // @@protoc_insertion_point(field_mutable:zproto.LoadBlockedUsersRsp.user_peers)
  return user_peers_.Mutable(index);
}
inline ::zproto::UserOutPeer* LoadBlockedUsersRsp::add_user_peers() {
  // @@protoc_insertion_point(field_add:zproto.LoadBlockedUsersRsp.user_peers)
  return user_peers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::zproto::UserOutPeer >*
LoadBlockedUsersRsp::mutable_user_peers() {
  // @@protoc_insertion_point(field_mutable_list:zproto.LoadBlockedUsersRsp.user_peers)
  return &user_peers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::zproto::UserOutPeer >&
LoadBlockedUsersRsp::user_peers() const {
  // @@protoc_insertion_point(field_list:zproto.LoadBlockedUsersRsp.user_peers)
  return user_peers_;
}

inline const LoadBlockedUsersRsp* LoadBlockedUsersRsp::internal_default_instance() {
  return &LoadBlockedUsersRsp_default_instance_.get();
}
// -------------------------------------------------------------------

// UserBlockedNotify

// optional int32 uid = 1;
inline void UserBlockedNotify::clear_uid() {
  uid_ = 0;
}
inline ::google::protobuf::int32 UserBlockedNotify::uid() const {
  // @@protoc_insertion_point(field_get:zproto.UserBlockedNotify.uid)
  return uid_;
}
inline void UserBlockedNotify::set_uid(::google::protobuf::int32 value) {
  
  uid_ = value;
  // @@protoc_insertion_point(field_set:zproto.UserBlockedNotify.uid)
}

inline const UserBlockedNotify* UserBlockedNotify::internal_default_instance() {
  return &UserBlockedNotify_default_instance_.get();
}
// -------------------------------------------------------------------

// UserUnblockedNotify

// optional int32 uid = 1;
inline void UserUnblockedNotify::clear_uid() {
  uid_ = 0;
}
inline ::google::protobuf::int32 UserUnblockedNotify::uid() const {
  // @@protoc_insertion_point(field_get:zproto.UserUnblockedNotify.uid)
  return uid_;
}
inline void UserUnblockedNotify::set_uid(::google::protobuf::int32 value) {
  
  uid_ = value;
  // @@protoc_insertion_point(field_set:zproto.UserUnblockedNotify.uid)
}

inline const UserUnblockedNotify* UserUnblockedNotify::internal_default_instance() {
  return &UserUnblockedNotify_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace zproto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_privacy_2eproto__INCLUDED
