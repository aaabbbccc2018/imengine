// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: schema.tl.transport.proto

#ifndef PROTOBUF_schema_2etl_2etransport_2eproto__INCLUDED
#define PROTOBUF_schema_2etl_2etransport_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "schema.tl.crc32.pb.h"
// @@protoc_insertion_point(includes)
namespace mtproto {
class AccessPointRule;
class AccessPointRuleDefaultTypeInternal;
extern AccessPointRuleDefaultTypeInternal _AccessPointRule_default_instance_;
class AccessPointRule_Data;
class AccessPointRule_DataDefaultTypeInternal;
extern AccessPointRule_DataDefaultTypeInternal _AccessPointRule_Data_default_instance_;
class BadMsgNotification;
class BadMsgNotificationDefaultTypeInternal;
extern BadMsgNotificationDefaultTypeInternal _BadMsgNotification_default_instance_;
class BadMsgNotification_Data;
class BadMsgNotification_DataDefaultTypeInternal;
extern BadMsgNotification_DataDefaultTypeInternal _BadMsgNotification_Data_default_instance_;
class DestroySessionRes;
class DestroySessionResDefaultTypeInternal;
extern DestroySessionResDefaultTypeInternal _DestroySessionRes_default_instance_;
class DestroySessionRes_Data;
class DestroySessionRes_DataDefaultTypeInternal;
extern DestroySessionRes_DataDefaultTypeInternal _DestroySessionRes_Data_default_instance_;
class FutureSalt;
class FutureSaltDefaultTypeInternal;
extern FutureSaltDefaultTypeInternal _FutureSalt_default_instance_;
class FutureSalt_Data;
class FutureSalt_DataDefaultTypeInternal;
extern FutureSalt_DataDefaultTypeInternal _FutureSalt_Data_default_instance_;
class FutureSalts;
class FutureSaltsDefaultTypeInternal;
extern FutureSaltsDefaultTypeInternal _FutureSalts_default_instance_;
class FutureSalts_Data;
class FutureSalts_DataDefaultTypeInternal;
extern FutureSalts_DataDefaultTypeInternal _FutureSalts_Data_default_instance_;
class HttpWait;
class HttpWaitDefaultTypeInternal;
extern HttpWaitDefaultTypeInternal _HttpWait_default_instance_;
class HttpWait_Data;
class HttpWait_DataDefaultTypeInternal;
extern HttpWait_DataDefaultTypeInternal _HttpWait_Data_default_instance_;
class IpPort;
class IpPortDefaultTypeInternal;
extern IpPortDefaultTypeInternal _IpPort_default_instance_;
class IpPort_Data;
class IpPort_DataDefaultTypeInternal;
extern IpPort_DataDefaultTypeInternal _IpPort_Data_default_instance_;
class MsgDetailedInfo;
class MsgDetailedInfoDefaultTypeInternal;
extern MsgDetailedInfoDefaultTypeInternal _MsgDetailedInfo_default_instance_;
class MsgDetailedInfo_Data;
class MsgDetailedInfo_DataDefaultTypeInternal;
extern MsgDetailedInfo_DataDefaultTypeInternal _MsgDetailedInfo_Data_default_instance_;
class MsgResendReq;
class MsgResendReqDefaultTypeInternal;
extern MsgResendReqDefaultTypeInternal _MsgResendReq_default_instance_;
class MsgResendReq_Data;
class MsgResendReq_DataDefaultTypeInternal;
extern MsgResendReq_DataDefaultTypeInternal _MsgResendReq_Data_default_instance_;
class MsgsAck;
class MsgsAckDefaultTypeInternal;
extern MsgsAckDefaultTypeInternal _MsgsAck_default_instance_;
class MsgsAck_Data;
class MsgsAck_DataDefaultTypeInternal;
extern MsgsAck_DataDefaultTypeInternal _MsgsAck_Data_default_instance_;
class MsgsAllInfo;
class MsgsAllInfoDefaultTypeInternal;
extern MsgsAllInfoDefaultTypeInternal _MsgsAllInfo_default_instance_;
class MsgsAllInfo_Data;
class MsgsAllInfo_DataDefaultTypeInternal;
extern MsgsAllInfo_DataDefaultTypeInternal _MsgsAllInfo_Data_default_instance_;
class MsgsStateInfo;
class MsgsStateInfoDefaultTypeInternal;
extern MsgsStateInfoDefaultTypeInternal _MsgsStateInfo_default_instance_;
class MsgsStateInfo_Data;
class MsgsStateInfo_DataDefaultTypeInternal;
extern MsgsStateInfo_DataDefaultTypeInternal _MsgsStateInfo_Data_default_instance_;
class MsgsStateReq;
class MsgsStateReqDefaultTypeInternal;
extern MsgsStateReqDefaultTypeInternal _MsgsStateReq_default_instance_;
class MsgsStateReq_Data;
class MsgsStateReq_DataDefaultTypeInternal;
extern MsgsStateReq_DataDefaultTypeInternal _MsgsStateReq_Data_default_instance_;
class NewSession;
class NewSessionDefaultTypeInternal;
extern NewSessionDefaultTypeInternal _NewSession_default_instance_;
class NewSession_Data;
class NewSession_DataDefaultTypeInternal;
extern NewSession_DataDefaultTypeInternal _NewSession_Data_default_instance_;
class Pong;
class PongDefaultTypeInternal;
extern PongDefaultTypeInternal _Pong_default_instance_;
class Pong_Data;
class Pong_DataDefaultTypeInternal;
extern Pong_DataDefaultTypeInternal _Pong_Data_default_instance_;
class RpcDropAnswer;
class RpcDropAnswerDefaultTypeInternal;
extern RpcDropAnswerDefaultTypeInternal _RpcDropAnswer_default_instance_;
class RpcDropAnswer_Data;
class RpcDropAnswer_DataDefaultTypeInternal;
extern RpcDropAnswer_DataDefaultTypeInternal _RpcDropAnswer_Data_default_instance_;
class RpcError;
class RpcErrorDefaultTypeInternal;
extern RpcErrorDefaultTypeInternal _RpcError_default_instance_;
class RpcError_Data;
class RpcError_DataDefaultTypeInternal;
extern RpcError_DataDefaultTypeInternal _RpcError_Data_default_instance_;
class TL_accessPointRule;
class TL_accessPointRuleDefaultTypeInternal;
extern TL_accessPointRuleDefaultTypeInternal _TL_accessPointRule_default_instance_;
class TL_bad_msg_notification;
class TL_bad_msg_notificationDefaultTypeInternal;
extern TL_bad_msg_notificationDefaultTypeInternal _TL_bad_msg_notification_default_instance_;
class TL_bad_server_salt;
class TL_bad_server_saltDefaultTypeInternal;
extern TL_bad_server_saltDefaultTypeInternal _TL_bad_server_salt_default_instance_;
class TL_destroy_session_none;
class TL_destroy_session_noneDefaultTypeInternal;
extern TL_destroy_session_noneDefaultTypeInternal _TL_destroy_session_none_default_instance_;
class TL_destroy_session_ok;
class TL_destroy_session_okDefaultTypeInternal;
extern TL_destroy_session_okDefaultTypeInternal _TL_destroy_session_ok_default_instance_;
class TL_future_salt;
class TL_future_saltDefaultTypeInternal;
extern TL_future_saltDefaultTypeInternal _TL_future_salt_default_instance_;
class TL_future_salts;
class TL_future_saltsDefaultTypeInternal;
extern TL_future_saltsDefaultTypeInternal _TL_future_salts_default_instance_;
class TL_help_configSimple;
class TL_help_configSimpleDefaultTypeInternal;
extern TL_help_configSimpleDefaultTypeInternal _TL_help_configSimple_default_instance_;
class TL_http_wait;
class TL_http_waitDefaultTypeInternal;
extern TL_http_waitDefaultTypeInternal _TL_http_wait_default_instance_;
class TL_ipPort;
class TL_ipPortDefaultTypeInternal;
extern TL_ipPortDefaultTypeInternal _TL_ipPort_default_instance_;
class TL_ipPortSecret;
class TL_ipPortSecretDefaultTypeInternal;
extern TL_ipPortSecretDefaultTypeInternal _TL_ipPortSecret_default_instance_;
class TL_msg_detailed_info;
class TL_msg_detailed_infoDefaultTypeInternal;
extern TL_msg_detailed_infoDefaultTypeInternal _TL_msg_detailed_info_default_instance_;
class TL_msg_new_detailed_info;
class TL_msg_new_detailed_infoDefaultTypeInternal;
extern TL_msg_new_detailed_infoDefaultTypeInternal _TL_msg_new_detailed_info_default_instance_;
class TL_msg_resend_req;
class TL_msg_resend_reqDefaultTypeInternal;
extern TL_msg_resend_reqDefaultTypeInternal _TL_msg_resend_req_default_instance_;
class TL_msgs_ack;
class TL_msgs_ackDefaultTypeInternal;
extern TL_msgs_ackDefaultTypeInternal _TL_msgs_ack_default_instance_;
class TL_msgs_all_info;
class TL_msgs_all_infoDefaultTypeInternal;
extern TL_msgs_all_infoDefaultTypeInternal _TL_msgs_all_info_default_instance_;
class TL_msgs_state_info;
class TL_msgs_state_infoDefaultTypeInternal;
extern TL_msgs_state_infoDefaultTypeInternal _TL_msgs_state_info_default_instance_;
class TL_msgs_state_req;
class TL_msgs_state_reqDefaultTypeInternal;
extern TL_msgs_state_reqDefaultTypeInternal _TL_msgs_state_req_default_instance_;
class TL_new_session_created;
class TL_new_session_createdDefaultTypeInternal;
extern TL_new_session_createdDefaultTypeInternal _TL_new_session_created_default_instance_;
class TL_pong;
class TL_pongDefaultTypeInternal;
extern TL_pongDefaultTypeInternal _TL_pong_default_instance_;
class TL_rpc_answer_dropped;
class TL_rpc_answer_droppedDefaultTypeInternal;
extern TL_rpc_answer_droppedDefaultTypeInternal _TL_rpc_answer_dropped_default_instance_;
class TL_rpc_answer_dropped_running;
class TL_rpc_answer_dropped_runningDefaultTypeInternal;
extern TL_rpc_answer_dropped_runningDefaultTypeInternal _TL_rpc_answer_dropped_running_default_instance_;
class TL_rpc_answer_unknown;
class TL_rpc_answer_unknownDefaultTypeInternal;
extern TL_rpc_answer_unknownDefaultTypeInternal _TL_rpc_answer_unknown_default_instance_;
class TL_rpc_error;
class TL_rpc_errorDefaultTypeInternal;
extern TL_rpc_errorDefaultTypeInternal _TL_rpc_error_default_instance_;
class help_ConfigSimple;
class help_ConfigSimpleDefaultTypeInternal;
extern help_ConfigSimpleDefaultTypeInternal _help_ConfigSimple_default_instance_;
class help_ConfigSimple_Data;
class help_ConfigSimple_DataDefaultTypeInternal;
extern help_ConfigSimple_DataDefaultTypeInternal _help_ConfigSimple_Data_default_instance_;
}  // namespace mtproto

namespace mtproto {

namespace protobuf_schema_2etl_2etransport_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_schema_2etl_2etransport_2eproto

// ===================================================================

class MsgsAck_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.MsgsAck_Data) */ {
 public:
  MsgsAck_Data();
  virtual ~MsgsAck_Data();

  MsgsAck_Data(const MsgsAck_Data& from);

  inline MsgsAck_Data& operator=(const MsgsAck_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgsAck_Data(MsgsAck_Data&& from) noexcept
    : MsgsAck_Data() {
    *this = ::std::move(from);
  }

  inline MsgsAck_Data& operator=(MsgsAck_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgsAck_Data& default_instance();

  static inline const MsgsAck_Data* internal_default_instance() {
    return reinterpret_cast<const MsgsAck_Data*>(
               &_MsgsAck_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(MsgsAck_Data* other);
  friend void swap(MsgsAck_Data& a, MsgsAck_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgsAck_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgsAck_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgsAck_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 msg_ids = 1;
  int msg_ids_size() const;
  void clear_msg_ids();
  static const int kMsgIdsFieldNumber = 1;
  ::google::protobuf::int64 msg_ids(int index) const;
  void set_msg_ids(int index, ::google::protobuf::int64 value);
  void add_msg_ids(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      msg_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_msg_ids();

  // @@protoc_insertion_point(class_scope:mtproto.MsgsAck_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > msg_ids_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MsgsAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.MsgsAck) */ {
 public:
  MsgsAck();
  virtual ~MsgsAck();

  MsgsAck(const MsgsAck& from);

  inline MsgsAck& operator=(const MsgsAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgsAck(MsgsAck&& from) noexcept
    : MsgsAck() {
    *this = ::std::move(from);
  }

  inline MsgsAck& operator=(MsgsAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgsAck& default_instance();

  static inline const MsgsAck* internal_default_instance() {
    return reinterpret_cast<const MsgsAck*>(
               &_MsgsAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(MsgsAck* other);
  friend void swap(MsgsAck& a, MsgsAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgsAck* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgsAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgsAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.MsgsAck_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::MsgsAck_Data& data2() const;
  ::mtproto::MsgsAck_Data* mutable_data2();
  ::mtproto::MsgsAck_Data* release_data2();
  void set_allocated_data2(::mtproto::MsgsAck_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.MsgsAck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::MsgsAck_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_msgs_ack : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_msgs_ack) */ {
 public:
  TL_msgs_ack();
  virtual ~TL_msgs_ack();

  TL_msgs_ack(const TL_msgs_ack& from);

  inline TL_msgs_ack& operator=(const TL_msgs_ack& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_msgs_ack(TL_msgs_ack&& from) noexcept
    : TL_msgs_ack() {
    *this = ::std::move(from);
  }

  inline TL_msgs_ack& operator=(TL_msgs_ack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_msgs_ack& default_instance();

  static inline const TL_msgs_ack* internal_default_instance() {
    return reinterpret_cast<const TL_msgs_ack*>(
               &_TL_msgs_ack_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(TL_msgs_ack* other);
  friend void swap(TL_msgs_ack& a, TL_msgs_ack& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_msgs_ack* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_msgs_ack* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_msgs_ack* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.MsgsAck_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::MsgsAck_Data& data2() const;
  ::mtproto::MsgsAck_Data* mutable_data2();
  ::mtproto::MsgsAck_Data* release_data2();
  void set_allocated_data2(::mtproto::MsgsAck_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_msgs_ack)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::MsgsAck_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BadMsgNotification_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.BadMsgNotification_Data) */ {
 public:
  BadMsgNotification_Data();
  virtual ~BadMsgNotification_Data();

  BadMsgNotification_Data(const BadMsgNotification_Data& from);

  inline BadMsgNotification_Data& operator=(const BadMsgNotification_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BadMsgNotification_Data(BadMsgNotification_Data&& from) noexcept
    : BadMsgNotification_Data() {
    *this = ::std::move(from);
  }

  inline BadMsgNotification_Data& operator=(BadMsgNotification_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BadMsgNotification_Data& default_instance();

  static inline const BadMsgNotification_Data* internal_default_instance() {
    return reinterpret_cast<const BadMsgNotification_Data*>(
               &_BadMsgNotification_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(BadMsgNotification_Data* other);
  friend void swap(BadMsgNotification_Data& a, BadMsgNotification_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BadMsgNotification_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  BadMsgNotification_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BadMsgNotification_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 bad_msg_id = 1;
  void clear_bad_msg_id();
  static const int kBadMsgIdFieldNumber = 1;
  ::google::protobuf::int64 bad_msg_id() const;
  void set_bad_msg_id(::google::protobuf::int64 value);

  // int32 bad_msg_seqno = 2;
  void clear_bad_msg_seqno();
  static const int kBadMsgSeqnoFieldNumber = 2;
  ::google::protobuf::int32 bad_msg_seqno() const;
  void set_bad_msg_seqno(::google::protobuf::int32 value);

  // int32 error_code = 3;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 3;
  ::google::protobuf::int32 error_code() const;
  void set_error_code(::google::protobuf::int32 value);

  // int64 new_server_salt = 4;
  void clear_new_server_salt();
  static const int kNewServerSaltFieldNumber = 4;
  ::google::protobuf::int64 new_server_salt() const;
  void set_new_server_salt(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mtproto.BadMsgNotification_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 bad_msg_id_;
  ::google::protobuf::int32 bad_msg_seqno_;
  ::google::protobuf::int32 error_code_;
  ::google::protobuf::int64 new_server_salt_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BadMsgNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.BadMsgNotification) */ {
 public:
  BadMsgNotification();
  virtual ~BadMsgNotification();

  BadMsgNotification(const BadMsgNotification& from);

  inline BadMsgNotification& operator=(const BadMsgNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BadMsgNotification(BadMsgNotification&& from) noexcept
    : BadMsgNotification() {
    *this = ::std::move(from);
  }

  inline BadMsgNotification& operator=(BadMsgNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BadMsgNotification& default_instance();

  static inline const BadMsgNotification* internal_default_instance() {
    return reinterpret_cast<const BadMsgNotification*>(
               &_BadMsgNotification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(BadMsgNotification* other);
  friend void swap(BadMsgNotification& a, BadMsgNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BadMsgNotification* New() const PROTOBUF_FINAL { return New(NULL); }

  BadMsgNotification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BadMsgNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.BadMsgNotification_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::BadMsgNotification_Data& data2() const;
  ::mtproto::BadMsgNotification_Data* mutable_data2();
  ::mtproto::BadMsgNotification_Data* release_data2();
  void set_allocated_data2(::mtproto::BadMsgNotification_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.BadMsgNotification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::BadMsgNotification_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_bad_msg_notification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_bad_msg_notification) */ {
 public:
  TL_bad_msg_notification();
  virtual ~TL_bad_msg_notification();

  TL_bad_msg_notification(const TL_bad_msg_notification& from);

  inline TL_bad_msg_notification& operator=(const TL_bad_msg_notification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_bad_msg_notification(TL_bad_msg_notification&& from) noexcept
    : TL_bad_msg_notification() {
    *this = ::std::move(from);
  }

  inline TL_bad_msg_notification& operator=(TL_bad_msg_notification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_bad_msg_notification& default_instance();

  static inline const TL_bad_msg_notification* internal_default_instance() {
    return reinterpret_cast<const TL_bad_msg_notification*>(
               &_TL_bad_msg_notification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(TL_bad_msg_notification* other);
  friend void swap(TL_bad_msg_notification& a, TL_bad_msg_notification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_bad_msg_notification* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_bad_msg_notification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_bad_msg_notification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.BadMsgNotification_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::BadMsgNotification_Data& data2() const;
  ::mtproto::BadMsgNotification_Data* mutable_data2();
  ::mtproto::BadMsgNotification_Data* release_data2();
  void set_allocated_data2(::mtproto::BadMsgNotification_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_bad_msg_notification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::BadMsgNotification_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_bad_server_salt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_bad_server_salt) */ {
 public:
  TL_bad_server_salt();
  virtual ~TL_bad_server_salt();

  TL_bad_server_salt(const TL_bad_server_salt& from);

  inline TL_bad_server_salt& operator=(const TL_bad_server_salt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_bad_server_salt(TL_bad_server_salt&& from) noexcept
    : TL_bad_server_salt() {
    *this = ::std::move(from);
  }

  inline TL_bad_server_salt& operator=(TL_bad_server_salt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_bad_server_salt& default_instance();

  static inline const TL_bad_server_salt* internal_default_instance() {
    return reinterpret_cast<const TL_bad_server_salt*>(
               &_TL_bad_server_salt_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(TL_bad_server_salt* other);
  friend void swap(TL_bad_server_salt& a, TL_bad_server_salt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_bad_server_salt* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_bad_server_salt* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_bad_server_salt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.BadMsgNotification_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::BadMsgNotification_Data& data2() const;
  ::mtproto::BadMsgNotification_Data* mutable_data2();
  ::mtproto::BadMsgNotification_Data* release_data2();
  void set_allocated_data2(::mtproto::BadMsgNotification_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_bad_server_salt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::BadMsgNotification_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FutureSalt_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.FutureSalt_Data) */ {
 public:
  FutureSalt_Data();
  virtual ~FutureSalt_Data();

  FutureSalt_Data(const FutureSalt_Data& from);

  inline FutureSalt_Data& operator=(const FutureSalt_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FutureSalt_Data(FutureSalt_Data&& from) noexcept
    : FutureSalt_Data() {
    *this = ::std::move(from);
  }

  inline FutureSalt_Data& operator=(FutureSalt_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FutureSalt_Data& default_instance();

  static inline const FutureSalt_Data* internal_default_instance() {
    return reinterpret_cast<const FutureSalt_Data*>(
               &_FutureSalt_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(FutureSalt_Data* other);
  friend void swap(FutureSalt_Data& a, FutureSalt_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FutureSalt_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  FutureSalt_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FutureSalt_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 valid_since = 1;
  void clear_valid_since();
  static const int kValidSinceFieldNumber = 1;
  ::google::protobuf::int32 valid_since() const;
  void set_valid_since(::google::protobuf::int32 value);

  // int32 valid_until = 2;
  void clear_valid_until();
  static const int kValidUntilFieldNumber = 2;
  ::google::protobuf::int32 valid_until() const;
  void set_valid_until(::google::protobuf::int32 value);

  // int64 salt = 3;
  void clear_salt();
  static const int kSaltFieldNumber = 3;
  ::google::protobuf::int64 salt() const;
  void set_salt(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mtproto.FutureSalt_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 valid_since_;
  ::google::protobuf::int32 valid_until_;
  ::google::protobuf::int64 salt_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FutureSalt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.FutureSalt) */ {
 public:
  FutureSalt();
  virtual ~FutureSalt();

  FutureSalt(const FutureSalt& from);

  inline FutureSalt& operator=(const FutureSalt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FutureSalt(FutureSalt&& from) noexcept
    : FutureSalt() {
    *this = ::std::move(from);
  }

  inline FutureSalt& operator=(FutureSalt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FutureSalt& default_instance();

  static inline const FutureSalt* internal_default_instance() {
    return reinterpret_cast<const FutureSalt*>(
               &_FutureSalt_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(FutureSalt* other);
  friend void swap(FutureSalt& a, FutureSalt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FutureSalt* New() const PROTOBUF_FINAL { return New(NULL); }

  FutureSalt* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FutureSalt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.FutureSalt_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::FutureSalt_Data& data2() const;
  ::mtproto::FutureSalt_Data* mutable_data2();
  ::mtproto::FutureSalt_Data* release_data2();
  void set_allocated_data2(::mtproto::FutureSalt_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.FutureSalt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::FutureSalt_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_future_salt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_future_salt) */ {
 public:
  TL_future_salt();
  virtual ~TL_future_salt();

  TL_future_salt(const TL_future_salt& from);

  inline TL_future_salt& operator=(const TL_future_salt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_future_salt(TL_future_salt&& from) noexcept
    : TL_future_salt() {
    *this = ::std::move(from);
  }

  inline TL_future_salt& operator=(TL_future_salt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_future_salt& default_instance();

  static inline const TL_future_salt* internal_default_instance() {
    return reinterpret_cast<const TL_future_salt*>(
               &_TL_future_salt_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(TL_future_salt* other);
  friend void swap(TL_future_salt& a, TL_future_salt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_future_salt* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_future_salt* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_future_salt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.FutureSalt_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::FutureSalt_Data& data2() const;
  ::mtproto::FutureSalt_Data* mutable_data2();
  ::mtproto::FutureSalt_Data* release_data2();
  void set_allocated_data2(::mtproto::FutureSalt_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_future_salt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::FutureSalt_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class help_ConfigSimple_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.help_ConfigSimple_Data) */ {
 public:
  help_ConfigSimple_Data();
  virtual ~help_ConfigSimple_Data();

  help_ConfigSimple_Data(const help_ConfigSimple_Data& from);

  inline help_ConfigSimple_Data& operator=(const help_ConfigSimple_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  help_ConfigSimple_Data(help_ConfigSimple_Data&& from) noexcept
    : help_ConfigSimple_Data() {
    *this = ::std::move(from);
  }

  inline help_ConfigSimple_Data& operator=(help_ConfigSimple_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const help_ConfigSimple_Data& default_instance();

  static inline const help_ConfigSimple_Data* internal_default_instance() {
    return reinterpret_cast<const help_ConfigSimple_Data*>(
               &_help_ConfigSimple_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(help_ConfigSimple_Data* other);
  friend void swap(help_ConfigSimple_Data& a, help_ConfigSimple_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline help_ConfigSimple_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  help_ConfigSimple_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(help_ConfigSimple_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mtproto.AccessPointRule rules = 3;
  int rules_size() const;
  void clear_rules();
  static const int kRulesFieldNumber = 3;
  const ::mtproto::AccessPointRule& rules(int index) const;
  ::mtproto::AccessPointRule* mutable_rules(int index);
  ::mtproto::AccessPointRule* add_rules();
  ::google::protobuf::RepeatedPtrField< ::mtproto::AccessPointRule >*
      mutable_rules();
  const ::google::protobuf::RepeatedPtrField< ::mtproto::AccessPointRule >&
      rules() const;

  // int32 date = 1;
  void clear_date();
  static const int kDateFieldNumber = 1;
  ::google::protobuf::int32 date() const;
  void set_date(::google::protobuf::int32 value);

  // int32 expires = 2;
  void clear_expires();
  static const int kExpiresFieldNumber = 2;
  ::google::protobuf::int32 expires() const;
  void set_expires(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mtproto.help_ConfigSimple_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::mtproto::AccessPointRule > rules_;
  ::google::protobuf::int32 date_;
  ::google::protobuf::int32 expires_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class help_ConfigSimple : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.help_ConfigSimple) */ {
 public:
  help_ConfigSimple();
  virtual ~help_ConfigSimple();

  help_ConfigSimple(const help_ConfigSimple& from);

  inline help_ConfigSimple& operator=(const help_ConfigSimple& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  help_ConfigSimple(help_ConfigSimple&& from) noexcept
    : help_ConfigSimple() {
    *this = ::std::move(from);
  }

  inline help_ConfigSimple& operator=(help_ConfigSimple&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const help_ConfigSimple& default_instance();

  static inline const help_ConfigSimple* internal_default_instance() {
    return reinterpret_cast<const help_ConfigSimple*>(
               &_help_ConfigSimple_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(help_ConfigSimple* other);
  friend void swap(help_ConfigSimple& a, help_ConfigSimple& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline help_ConfigSimple* New() const PROTOBUF_FINAL { return New(NULL); }

  help_ConfigSimple* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(help_ConfigSimple* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.help_ConfigSimple_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::help_ConfigSimple_Data& data2() const;
  ::mtproto::help_ConfigSimple_Data* mutable_data2();
  ::mtproto::help_ConfigSimple_Data* release_data2();
  void set_allocated_data2(::mtproto::help_ConfigSimple_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.help_ConfigSimple)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::help_ConfigSimple_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_help_configSimple : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_help_configSimple) */ {
 public:
  TL_help_configSimple();
  virtual ~TL_help_configSimple();

  TL_help_configSimple(const TL_help_configSimple& from);

  inline TL_help_configSimple& operator=(const TL_help_configSimple& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_help_configSimple(TL_help_configSimple&& from) noexcept
    : TL_help_configSimple() {
    *this = ::std::move(from);
  }

  inline TL_help_configSimple& operator=(TL_help_configSimple&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_help_configSimple& default_instance();

  static inline const TL_help_configSimple* internal_default_instance() {
    return reinterpret_cast<const TL_help_configSimple*>(
               &_TL_help_configSimple_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(TL_help_configSimple* other);
  friend void swap(TL_help_configSimple& a, TL_help_configSimple& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_help_configSimple* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_help_configSimple* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_help_configSimple* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.help_ConfigSimple_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::help_ConfigSimple_Data& data2() const;
  ::mtproto::help_ConfigSimple_Data* mutable_data2();
  ::mtproto::help_ConfigSimple_Data* release_data2();
  void set_allocated_data2(::mtproto::help_ConfigSimple_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_help_configSimple)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::help_ConfigSimple_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MsgResendReq_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.MsgResendReq_Data) */ {
 public:
  MsgResendReq_Data();
  virtual ~MsgResendReq_Data();

  MsgResendReq_Data(const MsgResendReq_Data& from);

  inline MsgResendReq_Data& operator=(const MsgResendReq_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgResendReq_Data(MsgResendReq_Data&& from) noexcept
    : MsgResendReq_Data() {
    *this = ::std::move(from);
  }

  inline MsgResendReq_Data& operator=(MsgResendReq_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgResendReq_Data& default_instance();

  static inline const MsgResendReq_Data* internal_default_instance() {
    return reinterpret_cast<const MsgResendReq_Data*>(
               &_MsgResendReq_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(MsgResendReq_Data* other);
  friend void swap(MsgResendReq_Data& a, MsgResendReq_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgResendReq_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgResendReq_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgResendReq_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 msg_ids = 1;
  int msg_ids_size() const;
  void clear_msg_ids();
  static const int kMsgIdsFieldNumber = 1;
  ::google::protobuf::int64 msg_ids(int index) const;
  void set_msg_ids(int index, ::google::protobuf::int64 value);
  void add_msg_ids(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      msg_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_msg_ids();

  // @@protoc_insertion_point(class_scope:mtproto.MsgResendReq_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > msg_ids_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MsgResendReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.MsgResendReq) */ {
 public:
  MsgResendReq();
  virtual ~MsgResendReq();

  MsgResendReq(const MsgResendReq& from);

  inline MsgResendReq& operator=(const MsgResendReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgResendReq(MsgResendReq&& from) noexcept
    : MsgResendReq() {
    *this = ::std::move(from);
  }

  inline MsgResendReq& operator=(MsgResendReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgResendReq& default_instance();

  static inline const MsgResendReq* internal_default_instance() {
    return reinterpret_cast<const MsgResendReq*>(
               &_MsgResendReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(MsgResendReq* other);
  friend void swap(MsgResendReq& a, MsgResendReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgResendReq* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgResendReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgResendReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.MsgResendReq_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::MsgResendReq_Data& data2() const;
  ::mtproto::MsgResendReq_Data* mutable_data2();
  ::mtproto::MsgResendReq_Data* release_data2();
  void set_allocated_data2(::mtproto::MsgResendReq_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.MsgResendReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::MsgResendReq_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_msg_resend_req : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_msg_resend_req) */ {
 public:
  TL_msg_resend_req();
  virtual ~TL_msg_resend_req();

  TL_msg_resend_req(const TL_msg_resend_req& from);

  inline TL_msg_resend_req& operator=(const TL_msg_resend_req& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_msg_resend_req(TL_msg_resend_req&& from) noexcept
    : TL_msg_resend_req() {
    *this = ::std::move(from);
  }

  inline TL_msg_resend_req& operator=(TL_msg_resend_req&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_msg_resend_req& default_instance();

  static inline const TL_msg_resend_req* internal_default_instance() {
    return reinterpret_cast<const TL_msg_resend_req*>(
               &_TL_msg_resend_req_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(TL_msg_resend_req* other);
  friend void swap(TL_msg_resend_req& a, TL_msg_resend_req& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_msg_resend_req* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_msg_resend_req* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_msg_resend_req* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.MsgResendReq_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::MsgResendReq_Data& data2() const;
  ::mtproto::MsgResendReq_Data* mutable_data2();
  ::mtproto::MsgResendReq_Data* release_data2();
  void set_allocated_data2(::mtproto::MsgResendReq_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_msg_resend_req)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::MsgResendReq_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewSession_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.NewSession_Data) */ {
 public:
  NewSession_Data();
  virtual ~NewSession_Data();

  NewSession_Data(const NewSession_Data& from);

  inline NewSession_Data& operator=(const NewSession_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewSession_Data(NewSession_Data&& from) noexcept
    : NewSession_Data() {
    *this = ::std::move(from);
  }

  inline NewSession_Data& operator=(NewSession_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewSession_Data& default_instance();

  static inline const NewSession_Data* internal_default_instance() {
    return reinterpret_cast<const NewSession_Data*>(
               &_NewSession_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(NewSession_Data* other);
  friend void swap(NewSession_Data& a, NewSession_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewSession_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  NewSession_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewSession_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 first_msg_id = 1;
  void clear_first_msg_id();
  static const int kFirstMsgIdFieldNumber = 1;
  ::google::protobuf::int64 first_msg_id() const;
  void set_first_msg_id(::google::protobuf::int64 value);

  // int64 unique_id = 2;
  void clear_unique_id();
  static const int kUniqueIdFieldNumber = 2;
  ::google::protobuf::int64 unique_id() const;
  void set_unique_id(::google::protobuf::int64 value);

  // int64 server_salt = 3;
  void clear_server_salt();
  static const int kServerSaltFieldNumber = 3;
  ::google::protobuf::int64 server_salt() const;
  void set_server_salt(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mtproto.NewSession_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 first_msg_id_;
  ::google::protobuf::int64 unique_id_;
  ::google::protobuf::int64 server_salt_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewSession : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.NewSession) */ {
 public:
  NewSession();
  virtual ~NewSession();

  NewSession(const NewSession& from);

  inline NewSession& operator=(const NewSession& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewSession(NewSession&& from) noexcept
    : NewSession() {
    *this = ::std::move(from);
  }

  inline NewSession& operator=(NewSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewSession& default_instance();

  static inline const NewSession* internal_default_instance() {
    return reinterpret_cast<const NewSession*>(
               &_NewSession_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(NewSession* other);
  friend void swap(NewSession& a, NewSession& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewSession* New() const PROTOBUF_FINAL { return New(NULL); }

  NewSession* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.NewSession_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::NewSession_Data& data2() const;
  ::mtproto::NewSession_Data* mutable_data2();
  ::mtproto::NewSession_Data* release_data2();
  void set_allocated_data2(::mtproto::NewSession_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.NewSession)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::NewSession_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_new_session_created : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_new_session_created) */ {
 public:
  TL_new_session_created();
  virtual ~TL_new_session_created();

  TL_new_session_created(const TL_new_session_created& from);

  inline TL_new_session_created& operator=(const TL_new_session_created& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_new_session_created(TL_new_session_created&& from) noexcept
    : TL_new_session_created() {
    *this = ::std::move(from);
  }

  inline TL_new_session_created& operator=(TL_new_session_created&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_new_session_created& default_instance();

  static inline const TL_new_session_created* internal_default_instance() {
    return reinterpret_cast<const TL_new_session_created*>(
               &_TL_new_session_created_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(TL_new_session_created* other);
  friend void swap(TL_new_session_created& a, TL_new_session_created& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_new_session_created* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_new_session_created* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_new_session_created* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.NewSession_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::NewSession_Data& data2() const;
  ::mtproto::NewSession_Data* mutable_data2();
  ::mtproto::NewSession_Data* release_data2();
  void set_allocated_data2(::mtproto::NewSession_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_new_session_created)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::NewSession_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IpPort_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.IpPort_Data) */ {
 public:
  IpPort_Data();
  virtual ~IpPort_Data();

  IpPort_Data(const IpPort_Data& from);

  inline IpPort_Data& operator=(const IpPort_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IpPort_Data(IpPort_Data&& from) noexcept
    : IpPort_Data() {
    *this = ::std::move(from);
  }

  inline IpPort_Data& operator=(IpPort_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IpPort_Data& default_instance();

  static inline const IpPort_Data* internal_default_instance() {
    return reinterpret_cast<const IpPort_Data*>(
               &_IpPort_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(IpPort_Data* other);
  friend void swap(IpPort_Data& a, IpPort_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IpPort_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  IpPort_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IpPort_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes secret = 3;
  void clear_secret();
  static const int kSecretFieldNumber = 3;
  const ::std::string& secret() const;
  void set_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_secret(::std::string&& value);
  #endif
  void set_secret(const char* value);
  void set_secret(const void* value, size_t size);
  ::std::string* mutable_secret();
  ::std::string* release_secret();
  void set_allocated_secret(::std::string* secret);

  // int32 ipv4 = 1;
  void clear_ipv4();
  static const int kIpv4FieldNumber = 1;
  ::google::protobuf::int32 ipv4() const;
  void set_ipv4(::google::protobuf::int32 value);

  // int32 port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mtproto.IpPort_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr secret_;
  ::google::protobuf::int32 ipv4_;
  ::google::protobuf::int32 port_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IpPort : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.IpPort) */ {
 public:
  IpPort();
  virtual ~IpPort();

  IpPort(const IpPort& from);

  inline IpPort& operator=(const IpPort& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IpPort(IpPort&& from) noexcept
    : IpPort() {
    *this = ::std::move(from);
  }

  inline IpPort& operator=(IpPort&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IpPort& default_instance();

  static inline const IpPort* internal_default_instance() {
    return reinterpret_cast<const IpPort*>(
               &_IpPort_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(IpPort* other);
  friend void swap(IpPort& a, IpPort& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IpPort* New() const PROTOBUF_FINAL { return New(NULL); }

  IpPort* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IpPort* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.IpPort_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::IpPort_Data& data2() const;
  ::mtproto::IpPort_Data* mutable_data2();
  ::mtproto::IpPort_Data* release_data2();
  void set_allocated_data2(::mtproto::IpPort_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.IpPort)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::IpPort_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_ipPort : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_ipPort) */ {
 public:
  TL_ipPort();
  virtual ~TL_ipPort();

  TL_ipPort(const TL_ipPort& from);

  inline TL_ipPort& operator=(const TL_ipPort& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_ipPort(TL_ipPort&& from) noexcept
    : TL_ipPort() {
    *this = ::std::move(from);
  }

  inline TL_ipPort& operator=(TL_ipPort&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_ipPort& default_instance();

  static inline const TL_ipPort* internal_default_instance() {
    return reinterpret_cast<const TL_ipPort*>(
               &_TL_ipPort_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(TL_ipPort* other);
  friend void swap(TL_ipPort& a, TL_ipPort& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_ipPort* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_ipPort* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_ipPort* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.IpPort_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::IpPort_Data& data2() const;
  ::mtproto::IpPort_Data* mutable_data2();
  ::mtproto::IpPort_Data* release_data2();
  void set_allocated_data2(::mtproto::IpPort_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_ipPort)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::IpPort_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_ipPortSecret : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_ipPortSecret) */ {
 public:
  TL_ipPortSecret();
  virtual ~TL_ipPortSecret();

  TL_ipPortSecret(const TL_ipPortSecret& from);

  inline TL_ipPortSecret& operator=(const TL_ipPortSecret& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_ipPortSecret(TL_ipPortSecret&& from) noexcept
    : TL_ipPortSecret() {
    *this = ::std::move(from);
  }

  inline TL_ipPortSecret& operator=(TL_ipPortSecret&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_ipPortSecret& default_instance();

  static inline const TL_ipPortSecret* internal_default_instance() {
    return reinterpret_cast<const TL_ipPortSecret*>(
               &_TL_ipPortSecret_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(TL_ipPortSecret* other);
  friend void swap(TL_ipPortSecret& a, TL_ipPortSecret& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_ipPortSecret* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_ipPortSecret* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_ipPortSecret* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.IpPort_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::IpPort_Data& data2() const;
  ::mtproto::IpPort_Data* mutable_data2();
  ::mtproto::IpPort_Data* release_data2();
  void set_allocated_data2(::mtproto::IpPort_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_ipPortSecret)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::IpPort_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MsgsStateReq_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.MsgsStateReq_Data) */ {
 public:
  MsgsStateReq_Data();
  virtual ~MsgsStateReq_Data();

  MsgsStateReq_Data(const MsgsStateReq_Data& from);

  inline MsgsStateReq_Data& operator=(const MsgsStateReq_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgsStateReq_Data(MsgsStateReq_Data&& from) noexcept
    : MsgsStateReq_Data() {
    *this = ::std::move(from);
  }

  inline MsgsStateReq_Data& operator=(MsgsStateReq_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgsStateReq_Data& default_instance();

  static inline const MsgsStateReq_Data* internal_default_instance() {
    return reinterpret_cast<const MsgsStateReq_Data*>(
               &_MsgsStateReq_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(MsgsStateReq_Data* other);
  friend void swap(MsgsStateReq_Data& a, MsgsStateReq_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgsStateReq_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgsStateReq_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgsStateReq_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 msg_ids = 1;
  int msg_ids_size() const;
  void clear_msg_ids();
  static const int kMsgIdsFieldNumber = 1;
  ::google::protobuf::int64 msg_ids(int index) const;
  void set_msg_ids(int index, ::google::protobuf::int64 value);
  void add_msg_ids(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      msg_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_msg_ids();

  // @@protoc_insertion_point(class_scope:mtproto.MsgsStateReq_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > msg_ids_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MsgsStateReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.MsgsStateReq) */ {
 public:
  MsgsStateReq();
  virtual ~MsgsStateReq();

  MsgsStateReq(const MsgsStateReq& from);

  inline MsgsStateReq& operator=(const MsgsStateReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgsStateReq(MsgsStateReq&& from) noexcept
    : MsgsStateReq() {
    *this = ::std::move(from);
  }

  inline MsgsStateReq& operator=(MsgsStateReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgsStateReq& default_instance();

  static inline const MsgsStateReq* internal_default_instance() {
    return reinterpret_cast<const MsgsStateReq*>(
               &_MsgsStateReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(MsgsStateReq* other);
  friend void swap(MsgsStateReq& a, MsgsStateReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgsStateReq* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgsStateReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgsStateReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.MsgsStateReq_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::MsgsStateReq_Data& data2() const;
  ::mtproto::MsgsStateReq_Data* mutable_data2();
  ::mtproto::MsgsStateReq_Data* release_data2();
  void set_allocated_data2(::mtproto::MsgsStateReq_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.MsgsStateReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::MsgsStateReq_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_msgs_state_req : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_msgs_state_req) */ {
 public:
  TL_msgs_state_req();
  virtual ~TL_msgs_state_req();

  TL_msgs_state_req(const TL_msgs_state_req& from);

  inline TL_msgs_state_req& operator=(const TL_msgs_state_req& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_msgs_state_req(TL_msgs_state_req&& from) noexcept
    : TL_msgs_state_req() {
    *this = ::std::move(from);
  }

  inline TL_msgs_state_req& operator=(TL_msgs_state_req&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_msgs_state_req& default_instance();

  static inline const TL_msgs_state_req* internal_default_instance() {
    return reinterpret_cast<const TL_msgs_state_req*>(
               &_TL_msgs_state_req_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(TL_msgs_state_req* other);
  friend void swap(TL_msgs_state_req& a, TL_msgs_state_req& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_msgs_state_req* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_msgs_state_req* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_msgs_state_req* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.MsgsStateReq_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::MsgsStateReq_Data& data2() const;
  ::mtproto::MsgsStateReq_Data* mutable_data2();
  ::mtproto::MsgsStateReq_Data* release_data2();
  void set_allocated_data2(::mtproto::MsgsStateReq_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_msgs_state_req)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::MsgsStateReq_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MsgsStateInfo_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.MsgsStateInfo_Data) */ {
 public:
  MsgsStateInfo_Data();
  virtual ~MsgsStateInfo_Data();

  MsgsStateInfo_Data(const MsgsStateInfo_Data& from);

  inline MsgsStateInfo_Data& operator=(const MsgsStateInfo_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgsStateInfo_Data(MsgsStateInfo_Data&& from) noexcept
    : MsgsStateInfo_Data() {
    *this = ::std::move(from);
  }

  inline MsgsStateInfo_Data& operator=(MsgsStateInfo_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgsStateInfo_Data& default_instance();

  static inline const MsgsStateInfo_Data* internal_default_instance() {
    return reinterpret_cast<const MsgsStateInfo_Data*>(
               &_MsgsStateInfo_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(MsgsStateInfo_Data* other);
  friend void swap(MsgsStateInfo_Data& a, MsgsStateInfo_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgsStateInfo_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgsStateInfo_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgsStateInfo_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string info = 2;
  void clear_info();
  static const int kInfoFieldNumber = 2;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // int64 req_msg_id = 1;
  void clear_req_msg_id();
  static const int kReqMsgIdFieldNumber = 1;
  ::google::protobuf::int64 req_msg_id() const;
  void set_req_msg_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mtproto.MsgsStateInfo_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  ::google::protobuf::int64 req_msg_id_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MsgsStateInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.MsgsStateInfo) */ {
 public:
  MsgsStateInfo();
  virtual ~MsgsStateInfo();

  MsgsStateInfo(const MsgsStateInfo& from);

  inline MsgsStateInfo& operator=(const MsgsStateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgsStateInfo(MsgsStateInfo&& from) noexcept
    : MsgsStateInfo() {
    *this = ::std::move(from);
  }

  inline MsgsStateInfo& operator=(MsgsStateInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgsStateInfo& default_instance();

  static inline const MsgsStateInfo* internal_default_instance() {
    return reinterpret_cast<const MsgsStateInfo*>(
               &_MsgsStateInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(MsgsStateInfo* other);
  friend void swap(MsgsStateInfo& a, MsgsStateInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgsStateInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgsStateInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgsStateInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.MsgsStateInfo_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::MsgsStateInfo_Data& data2() const;
  ::mtproto::MsgsStateInfo_Data* mutable_data2();
  ::mtproto::MsgsStateInfo_Data* release_data2();
  void set_allocated_data2(::mtproto::MsgsStateInfo_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.MsgsStateInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::MsgsStateInfo_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_msgs_state_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_msgs_state_info) */ {
 public:
  TL_msgs_state_info();
  virtual ~TL_msgs_state_info();

  TL_msgs_state_info(const TL_msgs_state_info& from);

  inline TL_msgs_state_info& operator=(const TL_msgs_state_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_msgs_state_info(TL_msgs_state_info&& from) noexcept
    : TL_msgs_state_info() {
    *this = ::std::move(from);
  }

  inline TL_msgs_state_info& operator=(TL_msgs_state_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_msgs_state_info& default_instance();

  static inline const TL_msgs_state_info* internal_default_instance() {
    return reinterpret_cast<const TL_msgs_state_info*>(
               &_TL_msgs_state_info_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(TL_msgs_state_info* other);
  friend void swap(TL_msgs_state_info& a, TL_msgs_state_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_msgs_state_info* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_msgs_state_info* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_msgs_state_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.MsgsStateInfo_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::MsgsStateInfo_Data& data2() const;
  ::mtproto::MsgsStateInfo_Data* mutable_data2();
  ::mtproto::MsgsStateInfo_Data* release_data2();
  void set_allocated_data2(::mtproto::MsgsStateInfo_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_msgs_state_info)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::MsgsStateInfo_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MsgsAllInfo_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.MsgsAllInfo_Data) */ {
 public:
  MsgsAllInfo_Data();
  virtual ~MsgsAllInfo_Data();

  MsgsAllInfo_Data(const MsgsAllInfo_Data& from);

  inline MsgsAllInfo_Data& operator=(const MsgsAllInfo_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgsAllInfo_Data(MsgsAllInfo_Data&& from) noexcept
    : MsgsAllInfo_Data() {
    *this = ::std::move(from);
  }

  inline MsgsAllInfo_Data& operator=(MsgsAllInfo_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgsAllInfo_Data& default_instance();

  static inline const MsgsAllInfo_Data* internal_default_instance() {
    return reinterpret_cast<const MsgsAllInfo_Data*>(
               &_MsgsAllInfo_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(MsgsAllInfo_Data* other);
  friend void swap(MsgsAllInfo_Data& a, MsgsAllInfo_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgsAllInfo_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgsAllInfo_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgsAllInfo_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 msg_ids = 1;
  int msg_ids_size() const;
  void clear_msg_ids();
  static const int kMsgIdsFieldNumber = 1;
  ::google::protobuf::int64 msg_ids(int index) const;
  void set_msg_ids(int index, ::google::protobuf::int64 value);
  void add_msg_ids(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      msg_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_msg_ids();

  // string info = 2;
  void clear_info();
  static const int kInfoFieldNumber = 2;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // @@protoc_insertion_point(class_scope:mtproto.MsgsAllInfo_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > msg_ids_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MsgsAllInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.MsgsAllInfo) */ {
 public:
  MsgsAllInfo();
  virtual ~MsgsAllInfo();

  MsgsAllInfo(const MsgsAllInfo& from);

  inline MsgsAllInfo& operator=(const MsgsAllInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgsAllInfo(MsgsAllInfo&& from) noexcept
    : MsgsAllInfo() {
    *this = ::std::move(from);
  }

  inline MsgsAllInfo& operator=(MsgsAllInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgsAllInfo& default_instance();

  static inline const MsgsAllInfo* internal_default_instance() {
    return reinterpret_cast<const MsgsAllInfo*>(
               &_MsgsAllInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(MsgsAllInfo* other);
  friend void swap(MsgsAllInfo& a, MsgsAllInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgsAllInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgsAllInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgsAllInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.MsgsAllInfo_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::MsgsAllInfo_Data& data2() const;
  ::mtproto::MsgsAllInfo_Data* mutable_data2();
  ::mtproto::MsgsAllInfo_Data* release_data2();
  void set_allocated_data2(::mtproto::MsgsAllInfo_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.MsgsAllInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::MsgsAllInfo_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_msgs_all_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_msgs_all_info) */ {
 public:
  TL_msgs_all_info();
  virtual ~TL_msgs_all_info();

  TL_msgs_all_info(const TL_msgs_all_info& from);

  inline TL_msgs_all_info& operator=(const TL_msgs_all_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_msgs_all_info(TL_msgs_all_info&& from) noexcept
    : TL_msgs_all_info() {
    *this = ::std::move(from);
  }

  inline TL_msgs_all_info& operator=(TL_msgs_all_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_msgs_all_info& default_instance();

  static inline const TL_msgs_all_info* internal_default_instance() {
    return reinterpret_cast<const TL_msgs_all_info*>(
               &_TL_msgs_all_info_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(TL_msgs_all_info* other);
  friend void swap(TL_msgs_all_info& a, TL_msgs_all_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_msgs_all_info* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_msgs_all_info* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_msgs_all_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.MsgsAllInfo_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::MsgsAllInfo_Data& data2() const;
  ::mtproto::MsgsAllInfo_Data* mutable_data2();
  ::mtproto::MsgsAllInfo_Data* release_data2();
  void set_allocated_data2(::mtproto::MsgsAllInfo_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_msgs_all_info)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::MsgsAllInfo_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MsgDetailedInfo_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.MsgDetailedInfo_Data) */ {
 public:
  MsgDetailedInfo_Data();
  virtual ~MsgDetailedInfo_Data();

  MsgDetailedInfo_Data(const MsgDetailedInfo_Data& from);

  inline MsgDetailedInfo_Data& operator=(const MsgDetailedInfo_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgDetailedInfo_Data(MsgDetailedInfo_Data&& from) noexcept
    : MsgDetailedInfo_Data() {
    *this = ::std::move(from);
  }

  inline MsgDetailedInfo_Data& operator=(MsgDetailedInfo_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgDetailedInfo_Data& default_instance();

  static inline const MsgDetailedInfo_Data* internal_default_instance() {
    return reinterpret_cast<const MsgDetailedInfo_Data*>(
               &_MsgDetailedInfo_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(MsgDetailedInfo_Data* other);
  friend void swap(MsgDetailedInfo_Data& a, MsgDetailedInfo_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgDetailedInfo_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgDetailedInfo_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgDetailedInfo_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 msg_id = 1;
  void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  ::google::protobuf::int64 msg_id() const;
  void set_msg_id(::google::protobuf::int64 value);

  // int64 answer_msg_id = 2;
  void clear_answer_msg_id();
  static const int kAnswerMsgIdFieldNumber = 2;
  ::google::protobuf::int64 answer_msg_id() const;
  void set_answer_msg_id(::google::protobuf::int64 value);

  // int32 bytes = 3;
  void clear_bytes();
  static const int kBytesFieldNumber = 3;
  ::google::protobuf::int32 bytes() const;
  void set_bytes(::google::protobuf::int32 value);

  // int32 status = 4;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mtproto.MsgDetailedInfo_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 msg_id_;
  ::google::protobuf::int64 answer_msg_id_;
  ::google::protobuf::int32 bytes_;
  ::google::protobuf::int32 status_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MsgDetailedInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.MsgDetailedInfo) */ {
 public:
  MsgDetailedInfo();
  virtual ~MsgDetailedInfo();

  MsgDetailedInfo(const MsgDetailedInfo& from);

  inline MsgDetailedInfo& operator=(const MsgDetailedInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgDetailedInfo(MsgDetailedInfo&& from) noexcept
    : MsgDetailedInfo() {
    *this = ::std::move(from);
  }

  inline MsgDetailedInfo& operator=(MsgDetailedInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgDetailedInfo& default_instance();

  static inline const MsgDetailedInfo* internal_default_instance() {
    return reinterpret_cast<const MsgDetailedInfo*>(
               &_MsgDetailedInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(MsgDetailedInfo* other);
  friend void swap(MsgDetailedInfo& a, MsgDetailedInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgDetailedInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgDetailedInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgDetailedInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.MsgDetailedInfo_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::MsgDetailedInfo_Data& data2() const;
  ::mtproto::MsgDetailedInfo_Data* mutable_data2();
  ::mtproto::MsgDetailedInfo_Data* release_data2();
  void set_allocated_data2(::mtproto::MsgDetailedInfo_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.MsgDetailedInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::MsgDetailedInfo_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_msg_detailed_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_msg_detailed_info) */ {
 public:
  TL_msg_detailed_info();
  virtual ~TL_msg_detailed_info();

  TL_msg_detailed_info(const TL_msg_detailed_info& from);

  inline TL_msg_detailed_info& operator=(const TL_msg_detailed_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_msg_detailed_info(TL_msg_detailed_info&& from) noexcept
    : TL_msg_detailed_info() {
    *this = ::std::move(from);
  }

  inline TL_msg_detailed_info& operator=(TL_msg_detailed_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_msg_detailed_info& default_instance();

  static inline const TL_msg_detailed_info* internal_default_instance() {
    return reinterpret_cast<const TL_msg_detailed_info*>(
               &_TL_msg_detailed_info_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(TL_msg_detailed_info* other);
  friend void swap(TL_msg_detailed_info& a, TL_msg_detailed_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_msg_detailed_info* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_msg_detailed_info* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_msg_detailed_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.MsgDetailedInfo_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::MsgDetailedInfo_Data& data2() const;
  ::mtproto::MsgDetailedInfo_Data* mutable_data2();
  ::mtproto::MsgDetailedInfo_Data* release_data2();
  void set_allocated_data2(::mtproto::MsgDetailedInfo_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_msg_detailed_info)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::MsgDetailedInfo_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_msg_new_detailed_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_msg_new_detailed_info) */ {
 public:
  TL_msg_new_detailed_info();
  virtual ~TL_msg_new_detailed_info();

  TL_msg_new_detailed_info(const TL_msg_new_detailed_info& from);

  inline TL_msg_new_detailed_info& operator=(const TL_msg_new_detailed_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_msg_new_detailed_info(TL_msg_new_detailed_info&& from) noexcept
    : TL_msg_new_detailed_info() {
    *this = ::std::move(from);
  }

  inline TL_msg_new_detailed_info& operator=(TL_msg_new_detailed_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_msg_new_detailed_info& default_instance();

  static inline const TL_msg_new_detailed_info* internal_default_instance() {
    return reinterpret_cast<const TL_msg_new_detailed_info*>(
               &_TL_msg_new_detailed_info_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(TL_msg_new_detailed_info* other);
  friend void swap(TL_msg_new_detailed_info& a, TL_msg_new_detailed_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_msg_new_detailed_info* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_msg_new_detailed_info* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_msg_new_detailed_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.MsgDetailedInfo_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::MsgDetailedInfo_Data& data2() const;
  ::mtproto::MsgDetailedInfo_Data* mutable_data2();
  ::mtproto::MsgDetailedInfo_Data* release_data2();
  void set_allocated_data2(::mtproto::MsgDetailedInfo_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_msg_new_detailed_info)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::MsgDetailedInfo_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccessPointRule_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.AccessPointRule_Data) */ {
 public:
  AccessPointRule_Data();
  virtual ~AccessPointRule_Data();

  AccessPointRule_Data(const AccessPointRule_Data& from);

  inline AccessPointRule_Data& operator=(const AccessPointRule_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessPointRule_Data(AccessPointRule_Data&& from) noexcept
    : AccessPointRule_Data() {
    *this = ::std::move(from);
  }

  inline AccessPointRule_Data& operator=(AccessPointRule_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessPointRule_Data& default_instance();

  static inline const AccessPointRule_Data* internal_default_instance() {
    return reinterpret_cast<const AccessPointRule_Data*>(
               &_AccessPointRule_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(AccessPointRule_Data* other);
  friend void swap(AccessPointRule_Data& a, AccessPointRule_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessPointRule_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  AccessPointRule_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccessPointRule_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mtproto.IpPort ips = 3;
  int ips_size() const;
  void clear_ips();
  static const int kIpsFieldNumber = 3;
  const ::mtproto::IpPort& ips(int index) const;
  ::mtproto::IpPort* mutable_ips(int index);
  ::mtproto::IpPort* add_ips();
  ::google::protobuf::RepeatedPtrField< ::mtproto::IpPort >*
      mutable_ips();
  const ::google::protobuf::RepeatedPtrField< ::mtproto::IpPort >&
      ips() const;

  // string phone_prefix_rules = 1;
  void clear_phone_prefix_rules();
  static const int kPhonePrefixRulesFieldNumber = 1;
  const ::std::string& phone_prefix_rules() const;
  void set_phone_prefix_rules(const ::std::string& value);
  #if LANG_CXX11
  void set_phone_prefix_rules(::std::string&& value);
  #endif
  void set_phone_prefix_rules(const char* value);
  void set_phone_prefix_rules(const char* value, size_t size);
  ::std::string* mutable_phone_prefix_rules();
  ::std::string* release_phone_prefix_rules();
  void set_allocated_phone_prefix_rules(::std::string* phone_prefix_rules);

  // int32 dc_id = 2;
  void clear_dc_id();
  static const int kDcIdFieldNumber = 2;
  ::google::protobuf::int32 dc_id() const;
  void set_dc_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mtproto.AccessPointRule_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::mtproto::IpPort > ips_;
  ::google::protobuf::internal::ArenaStringPtr phone_prefix_rules_;
  ::google::protobuf::int32 dc_id_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccessPointRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.AccessPointRule) */ {
 public:
  AccessPointRule();
  virtual ~AccessPointRule();

  AccessPointRule(const AccessPointRule& from);

  inline AccessPointRule& operator=(const AccessPointRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessPointRule(AccessPointRule&& from) noexcept
    : AccessPointRule() {
    *this = ::std::move(from);
  }

  inline AccessPointRule& operator=(AccessPointRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessPointRule& default_instance();

  static inline const AccessPointRule* internal_default_instance() {
    return reinterpret_cast<const AccessPointRule*>(
               &_AccessPointRule_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(AccessPointRule* other);
  friend void swap(AccessPointRule& a, AccessPointRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessPointRule* New() const PROTOBUF_FINAL { return New(NULL); }

  AccessPointRule* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccessPointRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.AccessPointRule_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::AccessPointRule_Data& data2() const;
  ::mtproto::AccessPointRule_Data* mutable_data2();
  ::mtproto::AccessPointRule_Data* release_data2();
  void set_allocated_data2(::mtproto::AccessPointRule_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.AccessPointRule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::AccessPointRule_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_accessPointRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_accessPointRule) */ {
 public:
  TL_accessPointRule();
  virtual ~TL_accessPointRule();

  TL_accessPointRule(const TL_accessPointRule& from);

  inline TL_accessPointRule& operator=(const TL_accessPointRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_accessPointRule(TL_accessPointRule&& from) noexcept
    : TL_accessPointRule() {
    *this = ::std::move(from);
  }

  inline TL_accessPointRule& operator=(TL_accessPointRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_accessPointRule& default_instance();

  static inline const TL_accessPointRule* internal_default_instance() {
    return reinterpret_cast<const TL_accessPointRule*>(
               &_TL_accessPointRule_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(TL_accessPointRule* other);
  friend void swap(TL_accessPointRule& a, TL_accessPointRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_accessPointRule* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_accessPointRule* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_accessPointRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.AccessPointRule_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::AccessPointRule_Data& data2() const;
  ::mtproto::AccessPointRule_Data* mutable_data2();
  ::mtproto::AccessPointRule_Data* release_data2();
  void set_allocated_data2(::mtproto::AccessPointRule_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_accessPointRule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::AccessPointRule_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RpcDropAnswer_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.RpcDropAnswer_Data) */ {
 public:
  RpcDropAnswer_Data();
  virtual ~RpcDropAnswer_Data();

  RpcDropAnswer_Data(const RpcDropAnswer_Data& from);

  inline RpcDropAnswer_Data& operator=(const RpcDropAnswer_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RpcDropAnswer_Data(RpcDropAnswer_Data&& from) noexcept
    : RpcDropAnswer_Data() {
    *this = ::std::move(from);
  }

  inline RpcDropAnswer_Data& operator=(RpcDropAnswer_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpcDropAnswer_Data& default_instance();

  static inline const RpcDropAnswer_Data* internal_default_instance() {
    return reinterpret_cast<const RpcDropAnswer_Data*>(
               &_RpcDropAnswer_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(RpcDropAnswer_Data* other);
  friend void swap(RpcDropAnswer_Data& a, RpcDropAnswer_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RpcDropAnswer_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  RpcDropAnswer_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RpcDropAnswer_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 msg_id = 1;
  void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  ::google::protobuf::int64 msg_id() const;
  void set_msg_id(::google::protobuf::int64 value);

  // int32 seq_no = 2;
  void clear_seq_no();
  static const int kSeqNoFieldNumber = 2;
  ::google::protobuf::int32 seq_no() const;
  void set_seq_no(::google::protobuf::int32 value);

  // int32 bytes = 3;
  void clear_bytes();
  static const int kBytesFieldNumber = 3;
  ::google::protobuf::int32 bytes() const;
  void set_bytes(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mtproto.RpcDropAnswer_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 msg_id_;
  ::google::protobuf::int32 seq_no_;
  ::google::protobuf::int32 bytes_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RpcDropAnswer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.RpcDropAnswer) */ {
 public:
  RpcDropAnswer();
  virtual ~RpcDropAnswer();

  RpcDropAnswer(const RpcDropAnswer& from);

  inline RpcDropAnswer& operator=(const RpcDropAnswer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RpcDropAnswer(RpcDropAnswer&& from) noexcept
    : RpcDropAnswer() {
    *this = ::std::move(from);
  }

  inline RpcDropAnswer& operator=(RpcDropAnswer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpcDropAnswer& default_instance();

  static inline const RpcDropAnswer* internal_default_instance() {
    return reinterpret_cast<const RpcDropAnswer*>(
               &_RpcDropAnswer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(RpcDropAnswer* other);
  friend void swap(RpcDropAnswer& a, RpcDropAnswer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RpcDropAnswer* New() const PROTOBUF_FINAL { return New(NULL); }

  RpcDropAnswer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RpcDropAnswer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.RpcDropAnswer_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::RpcDropAnswer_Data& data2() const;
  ::mtproto::RpcDropAnswer_Data* mutable_data2();
  ::mtproto::RpcDropAnswer_Data* release_data2();
  void set_allocated_data2(::mtproto::RpcDropAnswer_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.RpcDropAnswer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::RpcDropAnswer_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_rpc_answer_unknown : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_rpc_answer_unknown) */ {
 public:
  TL_rpc_answer_unknown();
  virtual ~TL_rpc_answer_unknown();

  TL_rpc_answer_unknown(const TL_rpc_answer_unknown& from);

  inline TL_rpc_answer_unknown& operator=(const TL_rpc_answer_unknown& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_rpc_answer_unknown(TL_rpc_answer_unknown&& from) noexcept
    : TL_rpc_answer_unknown() {
    *this = ::std::move(from);
  }

  inline TL_rpc_answer_unknown& operator=(TL_rpc_answer_unknown&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_rpc_answer_unknown& default_instance();

  static inline const TL_rpc_answer_unknown* internal_default_instance() {
    return reinterpret_cast<const TL_rpc_answer_unknown*>(
               &_TL_rpc_answer_unknown_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(TL_rpc_answer_unknown* other);
  friend void swap(TL_rpc_answer_unknown& a, TL_rpc_answer_unknown& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_rpc_answer_unknown* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_rpc_answer_unknown* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_rpc_answer_unknown* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.RpcDropAnswer_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::RpcDropAnswer_Data& data2() const;
  ::mtproto::RpcDropAnswer_Data* mutable_data2();
  ::mtproto::RpcDropAnswer_Data* release_data2();
  void set_allocated_data2(::mtproto::RpcDropAnswer_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_rpc_answer_unknown)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::RpcDropAnswer_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_rpc_answer_dropped_running : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_rpc_answer_dropped_running) */ {
 public:
  TL_rpc_answer_dropped_running();
  virtual ~TL_rpc_answer_dropped_running();

  TL_rpc_answer_dropped_running(const TL_rpc_answer_dropped_running& from);

  inline TL_rpc_answer_dropped_running& operator=(const TL_rpc_answer_dropped_running& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_rpc_answer_dropped_running(TL_rpc_answer_dropped_running&& from) noexcept
    : TL_rpc_answer_dropped_running() {
    *this = ::std::move(from);
  }

  inline TL_rpc_answer_dropped_running& operator=(TL_rpc_answer_dropped_running&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_rpc_answer_dropped_running& default_instance();

  static inline const TL_rpc_answer_dropped_running* internal_default_instance() {
    return reinterpret_cast<const TL_rpc_answer_dropped_running*>(
               &_TL_rpc_answer_dropped_running_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(TL_rpc_answer_dropped_running* other);
  friend void swap(TL_rpc_answer_dropped_running& a, TL_rpc_answer_dropped_running& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_rpc_answer_dropped_running* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_rpc_answer_dropped_running* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_rpc_answer_dropped_running* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.RpcDropAnswer_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::RpcDropAnswer_Data& data2() const;
  ::mtproto::RpcDropAnswer_Data* mutable_data2();
  ::mtproto::RpcDropAnswer_Data* release_data2();
  void set_allocated_data2(::mtproto::RpcDropAnswer_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_rpc_answer_dropped_running)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::RpcDropAnswer_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_rpc_answer_dropped : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_rpc_answer_dropped) */ {
 public:
  TL_rpc_answer_dropped();
  virtual ~TL_rpc_answer_dropped();

  TL_rpc_answer_dropped(const TL_rpc_answer_dropped& from);

  inline TL_rpc_answer_dropped& operator=(const TL_rpc_answer_dropped& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_rpc_answer_dropped(TL_rpc_answer_dropped&& from) noexcept
    : TL_rpc_answer_dropped() {
    *this = ::std::move(from);
  }

  inline TL_rpc_answer_dropped& operator=(TL_rpc_answer_dropped&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_rpc_answer_dropped& default_instance();

  static inline const TL_rpc_answer_dropped* internal_default_instance() {
    return reinterpret_cast<const TL_rpc_answer_dropped*>(
               &_TL_rpc_answer_dropped_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(TL_rpc_answer_dropped* other);
  friend void swap(TL_rpc_answer_dropped& a, TL_rpc_answer_dropped& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_rpc_answer_dropped* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_rpc_answer_dropped* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_rpc_answer_dropped* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.RpcDropAnswer_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::RpcDropAnswer_Data& data2() const;
  ::mtproto::RpcDropAnswer_Data* mutable_data2();
  ::mtproto::RpcDropAnswer_Data* release_data2();
  void set_allocated_data2(::mtproto::RpcDropAnswer_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_rpc_answer_dropped)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::RpcDropAnswer_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pong_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.Pong_Data) */ {
 public:
  Pong_Data();
  virtual ~Pong_Data();

  Pong_Data(const Pong_Data& from);

  inline Pong_Data& operator=(const Pong_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pong_Data(Pong_Data&& from) noexcept
    : Pong_Data() {
    *this = ::std::move(from);
  }

  inline Pong_Data& operator=(Pong_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pong_Data& default_instance();

  static inline const Pong_Data* internal_default_instance() {
    return reinterpret_cast<const Pong_Data*>(
               &_Pong_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(Pong_Data* other);
  friend void swap(Pong_Data& a, Pong_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pong_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  Pong_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Pong_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 msg_id = 1;
  void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  ::google::protobuf::int64 msg_id() const;
  void set_msg_id(::google::protobuf::int64 value);

  // int64 ping_id = 2;
  void clear_ping_id();
  static const int kPingIdFieldNumber = 2;
  ::google::protobuf::int64 ping_id() const;
  void set_ping_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mtproto.Pong_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 msg_id_;
  ::google::protobuf::int64 ping_id_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pong : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.Pong) */ {
 public:
  Pong();
  virtual ~Pong();

  Pong(const Pong& from);

  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pong(Pong&& from) noexcept
    : Pong() {
    *this = ::std::move(from);
  }

  inline Pong& operator=(Pong&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pong& default_instance();

  static inline const Pong* internal_default_instance() {
    return reinterpret_cast<const Pong*>(
               &_Pong_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(Pong* other);
  friend void swap(Pong& a, Pong& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pong* New() const PROTOBUF_FINAL { return New(NULL); }

  Pong* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Pong* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.Pong_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::Pong_Data& data2() const;
  ::mtproto::Pong_Data* mutable_data2();
  ::mtproto::Pong_Data* release_data2();
  void set_allocated_data2(::mtproto::Pong_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.Pong)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::Pong_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_pong : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_pong) */ {
 public:
  TL_pong();
  virtual ~TL_pong();

  TL_pong(const TL_pong& from);

  inline TL_pong& operator=(const TL_pong& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_pong(TL_pong&& from) noexcept
    : TL_pong() {
    *this = ::std::move(from);
  }

  inline TL_pong& operator=(TL_pong&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_pong& default_instance();

  static inline const TL_pong* internal_default_instance() {
    return reinterpret_cast<const TL_pong*>(
               &_TL_pong_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(TL_pong* other);
  friend void swap(TL_pong& a, TL_pong& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_pong* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_pong* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_pong* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.Pong_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::Pong_Data& data2() const;
  ::mtproto::Pong_Data* mutable_data2();
  ::mtproto::Pong_Data* release_data2();
  void set_allocated_data2(::mtproto::Pong_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_pong)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::Pong_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DestroySessionRes_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.DestroySessionRes_Data) */ {
 public:
  DestroySessionRes_Data();
  virtual ~DestroySessionRes_Data();

  DestroySessionRes_Data(const DestroySessionRes_Data& from);

  inline DestroySessionRes_Data& operator=(const DestroySessionRes_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DestroySessionRes_Data(DestroySessionRes_Data&& from) noexcept
    : DestroySessionRes_Data() {
    *this = ::std::move(from);
  }

  inline DestroySessionRes_Data& operator=(DestroySessionRes_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DestroySessionRes_Data& default_instance();

  static inline const DestroySessionRes_Data* internal_default_instance() {
    return reinterpret_cast<const DestroySessionRes_Data*>(
               &_DestroySessionRes_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void Swap(DestroySessionRes_Data* other);
  friend void swap(DestroySessionRes_Data& a, DestroySessionRes_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DestroySessionRes_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  DestroySessionRes_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DestroySessionRes_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 session_id = 1;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  ::google::protobuf::int64 session_id() const;
  void set_session_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mtproto.DestroySessionRes_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 session_id_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DestroySessionRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.DestroySessionRes) */ {
 public:
  DestroySessionRes();
  virtual ~DestroySessionRes();

  DestroySessionRes(const DestroySessionRes& from);

  inline DestroySessionRes& operator=(const DestroySessionRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DestroySessionRes(DestroySessionRes&& from) noexcept
    : DestroySessionRes() {
    *this = ::std::move(from);
  }

  inline DestroySessionRes& operator=(DestroySessionRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DestroySessionRes& default_instance();

  static inline const DestroySessionRes* internal_default_instance() {
    return reinterpret_cast<const DestroySessionRes*>(
               &_DestroySessionRes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void Swap(DestroySessionRes* other);
  friend void swap(DestroySessionRes& a, DestroySessionRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DestroySessionRes* New() const PROTOBUF_FINAL { return New(NULL); }

  DestroySessionRes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DestroySessionRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.DestroySessionRes_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::DestroySessionRes_Data& data2() const;
  ::mtproto::DestroySessionRes_Data* mutable_data2();
  ::mtproto::DestroySessionRes_Data* release_data2();
  void set_allocated_data2(::mtproto::DestroySessionRes_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.DestroySessionRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::DestroySessionRes_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_destroy_session_ok : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_destroy_session_ok) */ {
 public:
  TL_destroy_session_ok();
  virtual ~TL_destroy_session_ok();

  TL_destroy_session_ok(const TL_destroy_session_ok& from);

  inline TL_destroy_session_ok& operator=(const TL_destroy_session_ok& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_destroy_session_ok(TL_destroy_session_ok&& from) noexcept
    : TL_destroy_session_ok() {
    *this = ::std::move(from);
  }

  inline TL_destroy_session_ok& operator=(TL_destroy_session_ok&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_destroy_session_ok& default_instance();

  static inline const TL_destroy_session_ok* internal_default_instance() {
    return reinterpret_cast<const TL_destroy_session_ok*>(
               &_TL_destroy_session_ok_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void Swap(TL_destroy_session_ok* other);
  friend void swap(TL_destroy_session_ok& a, TL_destroy_session_ok& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_destroy_session_ok* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_destroy_session_ok* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_destroy_session_ok* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.DestroySessionRes_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::DestroySessionRes_Data& data2() const;
  ::mtproto::DestroySessionRes_Data* mutable_data2();
  ::mtproto::DestroySessionRes_Data* release_data2();
  void set_allocated_data2(::mtproto::DestroySessionRes_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_destroy_session_ok)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::DestroySessionRes_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_destroy_session_none : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_destroy_session_none) */ {
 public:
  TL_destroy_session_none();
  virtual ~TL_destroy_session_none();

  TL_destroy_session_none(const TL_destroy_session_none& from);

  inline TL_destroy_session_none& operator=(const TL_destroy_session_none& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_destroy_session_none(TL_destroy_session_none&& from) noexcept
    : TL_destroy_session_none() {
    *this = ::std::move(from);
  }

  inline TL_destroy_session_none& operator=(TL_destroy_session_none&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_destroy_session_none& default_instance();

  static inline const TL_destroy_session_none* internal_default_instance() {
    return reinterpret_cast<const TL_destroy_session_none*>(
               &_TL_destroy_session_none_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void Swap(TL_destroy_session_none* other);
  friend void swap(TL_destroy_session_none& a, TL_destroy_session_none& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_destroy_session_none* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_destroy_session_none* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_destroy_session_none* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.DestroySessionRes_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::DestroySessionRes_Data& data2() const;
  ::mtproto::DestroySessionRes_Data* mutable_data2();
  ::mtproto::DestroySessionRes_Data* release_data2();
  void set_allocated_data2(::mtproto::DestroySessionRes_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_destroy_session_none)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::DestroySessionRes_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HttpWait_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.HttpWait_Data) */ {
 public:
  HttpWait_Data();
  virtual ~HttpWait_Data();

  HttpWait_Data(const HttpWait_Data& from);

  inline HttpWait_Data& operator=(const HttpWait_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HttpWait_Data(HttpWait_Data&& from) noexcept
    : HttpWait_Data() {
    *this = ::std::move(from);
  }

  inline HttpWait_Data& operator=(HttpWait_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HttpWait_Data& default_instance();

  static inline const HttpWait_Data* internal_default_instance() {
    return reinterpret_cast<const HttpWait_Data*>(
               &_HttpWait_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void Swap(HttpWait_Data* other);
  friend void swap(HttpWait_Data& a, HttpWait_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HttpWait_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  HttpWait_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HttpWait_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 max_delay = 1;
  void clear_max_delay();
  static const int kMaxDelayFieldNumber = 1;
  ::google::protobuf::int32 max_delay() const;
  void set_max_delay(::google::protobuf::int32 value);

  // int32 wait_after = 2;
  void clear_wait_after();
  static const int kWaitAfterFieldNumber = 2;
  ::google::protobuf::int32 wait_after() const;
  void set_wait_after(::google::protobuf::int32 value);

  // int32 max_wait = 3;
  void clear_max_wait();
  static const int kMaxWaitFieldNumber = 3;
  ::google::protobuf::int32 max_wait() const;
  void set_max_wait(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mtproto.HttpWait_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 max_delay_;
  ::google::protobuf::int32 wait_after_;
  ::google::protobuf::int32 max_wait_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HttpWait : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.HttpWait) */ {
 public:
  HttpWait();
  virtual ~HttpWait();

  HttpWait(const HttpWait& from);

  inline HttpWait& operator=(const HttpWait& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HttpWait(HttpWait&& from) noexcept
    : HttpWait() {
    *this = ::std::move(from);
  }

  inline HttpWait& operator=(HttpWait&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HttpWait& default_instance();

  static inline const HttpWait* internal_default_instance() {
    return reinterpret_cast<const HttpWait*>(
               &_HttpWait_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    52;

  void Swap(HttpWait* other);
  friend void swap(HttpWait& a, HttpWait& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HttpWait* New() const PROTOBUF_FINAL { return New(NULL); }

  HttpWait* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HttpWait* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.HttpWait_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::HttpWait_Data& data2() const;
  ::mtproto::HttpWait_Data* mutable_data2();
  ::mtproto::HttpWait_Data* release_data2();
  void set_allocated_data2(::mtproto::HttpWait_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.HttpWait)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::HttpWait_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_http_wait : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_http_wait) */ {
 public:
  TL_http_wait();
  virtual ~TL_http_wait();

  TL_http_wait(const TL_http_wait& from);

  inline TL_http_wait& operator=(const TL_http_wait& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_http_wait(TL_http_wait&& from) noexcept
    : TL_http_wait() {
    *this = ::std::move(from);
  }

  inline TL_http_wait& operator=(TL_http_wait&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_http_wait& default_instance();

  static inline const TL_http_wait* internal_default_instance() {
    return reinterpret_cast<const TL_http_wait*>(
               &_TL_http_wait_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    53;

  void Swap(TL_http_wait* other);
  friend void swap(TL_http_wait& a, TL_http_wait& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_http_wait* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_http_wait* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_http_wait* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.HttpWait_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::HttpWait_Data& data2() const;
  ::mtproto::HttpWait_Data* mutable_data2();
  ::mtproto::HttpWait_Data* release_data2();
  void set_allocated_data2(::mtproto::HttpWait_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_http_wait)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::HttpWait_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RpcError_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.RpcError_Data) */ {
 public:
  RpcError_Data();
  virtual ~RpcError_Data();

  RpcError_Data(const RpcError_Data& from);

  inline RpcError_Data& operator=(const RpcError_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RpcError_Data(RpcError_Data&& from) noexcept
    : RpcError_Data() {
    *this = ::std::move(from);
  }

  inline RpcError_Data& operator=(RpcError_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpcError_Data& default_instance();

  static inline const RpcError_Data* internal_default_instance() {
    return reinterpret_cast<const RpcError_Data*>(
               &_RpcError_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    54;

  void Swap(RpcError_Data* other);
  friend void swap(RpcError_Data& a, RpcError_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RpcError_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  RpcError_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RpcError_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error_message = 2;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 2;
  const ::std::string& error_message() const;
  void set_error_message(const ::std::string& value);
  #if LANG_CXX11
  void set_error_message(::std::string&& value);
  #endif
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  ::std::string* mutable_error_message();
  ::std::string* release_error_message();
  void set_allocated_error_message(::std::string* error_message);

  // int32 error_code = 1;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::int32 error_code() const;
  void set_error_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mtproto.RpcError_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_message_;
  ::google::protobuf::int32 error_code_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RpcError : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.RpcError) */ {
 public:
  RpcError();
  virtual ~RpcError();

  RpcError(const RpcError& from);

  inline RpcError& operator=(const RpcError& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RpcError(RpcError&& from) noexcept
    : RpcError() {
    *this = ::std::move(from);
  }

  inline RpcError& operator=(RpcError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpcError& default_instance();

  static inline const RpcError* internal_default_instance() {
    return reinterpret_cast<const RpcError*>(
               &_RpcError_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    55;

  void Swap(RpcError* other);
  friend void swap(RpcError& a, RpcError& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RpcError* New() const PROTOBUF_FINAL { return New(NULL); }

  RpcError* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RpcError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.RpcError_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::RpcError_Data& data2() const;
  ::mtproto::RpcError_Data* mutable_data2();
  ::mtproto::RpcError_Data* release_data2();
  void set_allocated_data2(::mtproto::RpcError_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.RpcError)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::RpcError_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_rpc_error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_rpc_error) */ {
 public:
  TL_rpc_error();
  virtual ~TL_rpc_error();

  TL_rpc_error(const TL_rpc_error& from);

  inline TL_rpc_error& operator=(const TL_rpc_error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_rpc_error(TL_rpc_error&& from) noexcept
    : TL_rpc_error() {
    *this = ::std::move(from);
  }

  inline TL_rpc_error& operator=(TL_rpc_error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_rpc_error& default_instance();

  static inline const TL_rpc_error* internal_default_instance() {
    return reinterpret_cast<const TL_rpc_error*>(
               &_TL_rpc_error_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    56;

  void Swap(TL_rpc_error* other);
  friend void swap(TL_rpc_error& a, TL_rpc_error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_rpc_error* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_rpc_error* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_rpc_error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.RpcError_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::RpcError_Data& data2() const;
  ::mtproto::RpcError_Data* mutable_data2();
  ::mtproto::RpcError_Data* release_data2();
  void set_allocated_data2(::mtproto::RpcError_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_rpc_error)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::RpcError_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FutureSalts_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.FutureSalts_Data) */ {
 public:
  FutureSalts_Data();
  virtual ~FutureSalts_Data();

  FutureSalts_Data(const FutureSalts_Data& from);

  inline FutureSalts_Data& operator=(const FutureSalts_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FutureSalts_Data(FutureSalts_Data&& from) noexcept
    : FutureSalts_Data() {
    *this = ::std::move(from);
  }

  inline FutureSalts_Data& operator=(FutureSalts_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FutureSalts_Data& default_instance();

  static inline const FutureSalts_Data* internal_default_instance() {
    return reinterpret_cast<const FutureSalts_Data*>(
               &_FutureSalts_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    57;

  void Swap(FutureSalts_Data* other);
  friend void swap(FutureSalts_Data& a, FutureSalts_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FutureSalts_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  FutureSalts_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FutureSalts_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mtproto.TL_future_salt salts = 3;
  int salts_size() const;
  void clear_salts();
  static const int kSaltsFieldNumber = 3;
  const ::mtproto::TL_future_salt& salts(int index) const;
  ::mtproto::TL_future_salt* mutable_salts(int index);
  ::mtproto::TL_future_salt* add_salts();
  ::google::protobuf::RepeatedPtrField< ::mtproto::TL_future_salt >*
      mutable_salts();
  const ::google::protobuf::RepeatedPtrField< ::mtproto::TL_future_salt >&
      salts() const;

  // int64 req_msg_id = 1;
  void clear_req_msg_id();
  static const int kReqMsgIdFieldNumber = 1;
  ::google::protobuf::int64 req_msg_id() const;
  void set_req_msg_id(::google::protobuf::int64 value);

  // int32 now = 2;
  void clear_now();
  static const int kNowFieldNumber = 2;
  ::google::protobuf::int32 now() const;
  void set_now(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mtproto.FutureSalts_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::mtproto::TL_future_salt > salts_;
  ::google::protobuf::int64 req_msg_id_;
  ::google::protobuf::int32 now_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FutureSalts : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.FutureSalts) */ {
 public:
  FutureSalts();
  virtual ~FutureSalts();

  FutureSalts(const FutureSalts& from);

  inline FutureSalts& operator=(const FutureSalts& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FutureSalts(FutureSalts&& from) noexcept
    : FutureSalts() {
    *this = ::std::move(from);
  }

  inline FutureSalts& operator=(FutureSalts&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FutureSalts& default_instance();

  static inline const FutureSalts* internal_default_instance() {
    return reinterpret_cast<const FutureSalts*>(
               &_FutureSalts_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    58;

  void Swap(FutureSalts* other);
  friend void swap(FutureSalts& a, FutureSalts& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FutureSalts* New() const PROTOBUF_FINAL { return New(NULL); }

  FutureSalts* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FutureSalts* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.FutureSalts_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::FutureSalts_Data& data2() const;
  ::mtproto::FutureSalts_Data* mutable_data2();
  ::mtproto::FutureSalts_Data* release_data2();
  void set_allocated_data2(::mtproto::FutureSalts_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.FutureSalts)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::FutureSalts_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_future_salts : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_future_salts) */ {
 public:
  TL_future_salts();
  virtual ~TL_future_salts();

  TL_future_salts(const TL_future_salts& from);

  inline TL_future_salts& operator=(const TL_future_salts& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_future_salts(TL_future_salts&& from) noexcept
    : TL_future_salts() {
    *this = ::std::move(from);
  }

  inline TL_future_salts& operator=(TL_future_salts&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_future_salts& default_instance();

  static inline const TL_future_salts* internal_default_instance() {
    return reinterpret_cast<const TL_future_salts*>(
               &_TL_future_salts_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    59;

  void Swap(TL_future_salts* other);
  friend void swap(TL_future_salts& a, TL_future_salts& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_future_salts* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_future_salts* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_future_salts* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.FutureSalts_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::FutureSalts_Data& data2() const;
  ::mtproto::FutureSalts_Data* mutable_data2();
  ::mtproto::FutureSalts_Data* release_data2();
  void set_allocated_data2(::mtproto::FutureSalts_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_future_salts)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::FutureSalts_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2etransport_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MsgsAck_Data

// repeated int64 msg_ids = 1;
inline int MsgsAck_Data::msg_ids_size() const {
  return msg_ids_.size();
}
inline void MsgsAck_Data::clear_msg_ids() {
  msg_ids_.Clear();
}
inline ::google::protobuf::int64 MsgsAck_Data::msg_ids(int index) const {
  // @@protoc_insertion_point(field_get:mtproto.MsgsAck_Data.msg_ids)
  return msg_ids_.Get(index);
}
inline void MsgsAck_Data::set_msg_ids(int index, ::google::protobuf::int64 value) {
  msg_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:mtproto.MsgsAck_Data.msg_ids)
}
inline void MsgsAck_Data::add_msg_ids(::google::protobuf::int64 value) {
  msg_ids_.Add(value);
  // @@protoc_insertion_point(field_add:mtproto.MsgsAck_Data.msg_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
MsgsAck_Data::msg_ids() const {
  // @@protoc_insertion_point(field_list:mtproto.MsgsAck_Data.msg_ids)
  return msg_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
MsgsAck_Data::mutable_msg_ids() {
  // @@protoc_insertion_point(field_mutable_list:mtproto.MsgsAck_Data.msg_ids)
  return &msg_ids_;
}

// -------------------------------------------------------------------

// MsgsAck

// .mtproto.TLConstructor constructor = 1;
inline void MsgsAck::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor MsgsAck::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.MsgsAck.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void MsgsAck::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.MsgsAck.constructor)
}

// .mtproto.MsgsAck_Data data2 = 2;
inline bool MsgsAck::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void MsgsAck::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::MsgsAck_Data& MsgsAck::data2() const {
  const ::mtproto::MsgsAck_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.MsgsAck.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::MsgsAck_Data*>(
      &::mtproto::_MsgsAck_Data_default_instance_);
}
inline ::mtproto::MsgsAck_Data* MsgsAck::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::MsgsAck_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.MsgsAck.data2)
  return data2_;
}
inline ::mtproto::MsgsAck_Data* MsgsAck::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.MsgsAck.data2)
  
  ::mtproto::MsgsAck_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void MsgsAck::set_allocated_data2(::mtproto::MsgsAck_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.MsgsAck.data2)
}

// -------------------------------------------------------------------

// TL_msgs_ack

// .mtproto.MsgsAck_Data data2 = 2;
inline bool TL_msgs_ack::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_msgs_ack::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::MsgsAck_Data& TL_msgs_ack::data2() const {
  const ::mtproto::MsgsAck_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_msgs_ack.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::MsgsAck_Data*>(
      &::mtproto::_MsgsAck_Data_default_instance_);
}
inline ::mtproto::MsgsAck_Data* TL_msgs_ack::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::MsgsAck_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_msgs_ack.data2)
  return data2_;
}
inline ::mtproto::MsgsAck_Data* TL_msgs_ack::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_msgs_ack.data2)
  
  ::mtproto::MsgsAck_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_msgs_ack::set_allocated_data2(::mtproto::MsgsAck_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_msgs_ack.data2)
}

// -------------------------------------------------------------------

// BadMsgNotification_Data

// int64 bad_msg_id = 1;
inline void BadMsgNotification_Data::clear_bad_msg_id() {
  bad_msg_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BadMsgNotification_Data::bad_msg_id() const {
  // @@protoc_insertion_point(field_get:mtproto.BadMsgNotification_Data.bad_msg_id)
  return bad_msg_id_;
}
inline void BadMsgNotification_Data::set_bad_msg_id(::google::protobuf::int64 value) {
  
  bad_msg_id_ = value;
  // @@protoc_insertion_point(field_set:mtproto.BadMsgNotification_Data.bad_msg_id)
}

// int32 bad_msg_seqno = 2;
inline void BadMsgNotification_Data::clear_bad_msg_seqno() {
  bad_msg_seqno_ = 0;
}
inline ::google::protobuf::int32 BadMsgNotification_Data::bad_msg_seqno() const {
  // @@protoc_insertion_point(field_get:mtproto.BadMsgNotification_Data.bad_msg_seqno)
  return bad_msg_seqno_;
}
inline void BadMsgNotification_Data::set_bad_msg_seqno(::google::protobuf::int32 value) {
  
  bad_msg_seqno_ = value;
  // @@protoc_insertion_point(field_set:mtproto.BadMsgNotification_Data.bad_msg_seqno)
}

// int32 error_code = 3;
inline void BadMsgNotification_Data::clear_error_code() {
  error_code_ = 0;
}
inline ::google::protobuf::int32 BadMsgNotification_Data::error_code() const {
  // @@protoc_insertion_point(field_get:mtproto.BadMsgNotification_Data.error_code)
  return error_code_;
}
inline void BadMsgNotification_Data::set_error_code(::google::protobuf::int32 value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:mtproto.BadMsgNotification_Data.error_code)
}

// int64 new_server_salt = 4;
inline void BadMsgNotification_Data::clear_new_server_salt() {
  new_server_salt_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BadMsgNotification_Data::new_server_salt() const {
  // @@protoc_insertion_point(field_get:mtproto.BadMsgNotification_Data.new_server_salt)
  return new_server_salt_;
}
inline void BadMsgNotification_Data::set_new_server_salt(::google::protobuf::int64 value) {
  
  new_server_salt_ = value;
  // @@protoc_insertion_point(field_set:mtproto.BadMsgNotification_Data.new_server_salt)
}

// -------------------------------------------------------------------

// BadMsgNotification

// .mtproto.TLConstructor constructor = 1;
inline void BadMsgNotification::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor BadMsgNotification::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.BadMsgNotification.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void BadMsgNotification::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.BadMsgNotification.constructor)
}

// .mtproto.BadMsgNotification_Data data2 = 2;
inline bool BadMsgNotification::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void BadMsgNotification::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::BadMsgNotification_Data& BadMsgNotification::data2() const {
  const ::mtproto::BadMsgNotification_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.BadMsgNotification.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::BadMsgNotification_Data*>(
      &::mtproto::_BadMsgNotification_Data_default_instance_);
}
inline ::mtproto::BadMsgNotification_Data* BadMsgNotification::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::BadMsgNotification_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.BadMsgNotification.data2)
  return data2_;
}
inline ::mtproto::BadMsgNotification_Data* BadMsgNotification::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.BadMsgNotification.data2)
  
  ::mtproto::BadMsgNotification_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void BadMsgNotification::set_allocated_data2(::mtproto::BadMsgNotification_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.BadMsgNotification.data2)
}

// -------------------------------------------------------------------

// TL_bad_msg_notification

// .mtproto.BadMsgNotification_Data data2 = 2;
inline bool TL_bad_msg_notification::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_bad_msg_notification::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::BadMsgNotification_Data& TL_bad_msg_notification::data2() const {
  const ::mtproto::BadMsgNotification_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_bad_msg_notification.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::BadMsgNotification_Data*>(
      &::mtproto::_BadMsgNotification_Data_default_instance_);
}
inline ::mtproto::BadMsgNotification_Data* TL_bad_msg_notification::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::BadMsgNotification_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_bad_msg_notification.data2)
  return data2_;
}
inline ::mtproto::BadMsgNotification_Data* TL_bad_msg_notification::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_bad_msg_notification.data2)
  
  ::mtproto::BadMsgNotification_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_bad_msg_notification::set_allocated_data2(::mtproto::BadMsgNotification_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_bad_msg_notification.data2)
}

// -------------------------------------------------------------------

// TL_bad_server_salt

// .mtproto.BadMsgNotification_Data data2 = 2;
inline bool TL_bad_server_salt::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_bad_server_salt::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::BadMsgNotification_Data& TL_bad_server_salt::data2() const {
  const ::mtproto::BadMsgNotification_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_bad_server_salt.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::BadMsgNotification_Data*>(
      &::mtproto::_BadMsgNotification_Data_default_instance_);
}
inline ::mtproto::BadMsgNotification_Data* TL_bad_server_salt::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::BadMsgNotification_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_bad_server_salt.data2)
  return data2_;
}
inline ::mtproto::BadMsgNotification_Data* TL_bad_server_salt::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_bad_server_salt.data2)
  
  ::mtproto::BadMsgNotification_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_bad_server_salt::set_allocated_data2(::mtproto::BadMsgNotification_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_bad_server_salt.data2)
}

// -------------------------------------------------------------------

// FutureSalt_Data

// int32 valid_since = 1;
inline void FutureSalt_Data::clear_valid_since() {
  valid_since_ = 0;
}
inline ::google::protobuf::int32 FutureSalt_Data::valid_since() const {
  // @@protoc_insertion_point(field_get:mtproto.FutureSalt_Data.valid_since)
  return valid_since_;
}
inline void FutureSalt_Data::set_valid_since(::google::protobuf::int32 value) {
  
  valid_since_ = value;
  // @@protoc_insertion_point(field_set:mtproto.FutureSalt_Data.valid_since)
}

// int32 valid_until = 2;
inline void FutureSalt_Data::clear_valid_until() {
  valid_until_ = 0;
}
inline ::google::protobuf::int32 FutureSalt_Data::valid_until() const {
  // @@protoc_insertion_point(field_get:mtproto.FutureSalt_Data.valid_until)
  return valid_until_;
}
inline void FutureSalt_Data::set_valid_until(::google::protobuf::int32 value) {
  
  valid_until_ = value;
  // @@protoc_insertion_point(field_set:mtproto.FutureSalt_Data.valid_until)
}

// int64 salt = 3;
inline void FutureSalt_Data::clear_salt() {
  salt_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 FutureSalt_Data::salt() const {
  // @@protoc_insertion_point(field_get:mtproto.FutureSalt_Data.salt)
  return salt_;
}
inline void FutureSalt_Data::set_salt(::google::protobuf::int64 value) {
  
  salt_ = value;
  // @@protoc_insertion_point(field_set:mtproto.FutureSalt_Data.salt)
}

// -------------------------------------------------------------------

// FutureSalt

// .mtproto.TLConstructor constructor = 1;
inline void FutureSalt::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor FutureSalt::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.FutureSalt.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void FutureSalt::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.FutureSalt.constructor)
}

// .mtproto.FutureSalt_Data data2 = 2;
inline bool FutureSalt::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void FutureSalt::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::FutureSalt_Data& FutureSalt::data2() const {
  const ::mtproto::FutureSalt_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.FutureSalt.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::FutureSalt_Data*>(
      &::mtproto::_FutureSalt_Data_default_instance_);
}
inline ::mtproto::FutureSalt_Data* FutureSalt::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::FutureSalt_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.FutureSalt.data2)
  return data2_;
}
inline ::mtproto::FutureSalt_Data* FutureSalt::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.FutureSalt.data2)
  
  ::mtproto::FutureSalt_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void FutureSalt::set_allocated_data2(::mtproto::FutureSalt_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.FutureSalt.data2)
}

// -------------------------------------------------------------------

// TL_future_salt

// .mtproto.FutureSalt_Data data2 = 2;
inline bool TL_future_salt::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_future_salt::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::FutureSalt_Data& TL_future_salt::data2() const {
  const ::mtproto::FutureSalt_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_future_salt.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::FutureSalt_Data*>(
      &::mtproto::_FutureSalt_Data_default_instance_);
}
inline ::mtproto::FutureSalt_Data* TL_future_salt::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::FutureSalt_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_future_salt.data2)
  return data2_;
}
inline ::mtproto::FutureSalt_Data* TL_future_salt::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_future_salt.data2)
  
  ::mtproto::FutureSalt_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_future_salt::set_allocated_data2(::mtproto::FutureSalt_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_future_salt.data2)
}

// -------------------------------------------------------------------

// help_ConfigSimple_Data

// int32 date = 1;
inline void help_ConfigSimple_Data::clear_date() {
  date_ = 0;
}
inline ::google::protobuf::int32 help_ConfigSimple_Data::date() const {
  // @@protoc_insertion_point(field_get:mtproto.help_ConfigSimple_Data.date)
  return date_;
}
inline void help_ConfigSimple_Data::set_date(::google::protobuf::int32 value) {
  
  date_ = value;
  // @@protoc_insertion_point(field_set:mtproto.help_ConfigSimple_Data.date)
}

// int32 expires = 2;
inline void help_ConfigSimple_Data::clear_expires() {
  expires_ = 0;
}
inline ::google::protobuf::int32 help_ConfigSimple_Data::expires() const {
  // @@protoc_insertion_point(field_get:mtproto.help_ConfigSimple_Data.expires)
  return expires_;
}
inline void help_ConfigSimple_Data::set_expires(::google::protobuf::int32 value) {
  
  expires_ = value;
  // @@protoc_insertion_point(field_set:mtproto.help_ConfigSimple_Data.expires)
}

// repeated .mtproto.AccessPointRule rules = 3;
inline int help_ConfigSimple_Data::rules_size() const {
  return rules_.size();
}
inline void help_ConfigSimple_Data::clear_rules() {
  rules_.Clear();
}
inline const ::mtproto::AccessPointRule& help_ConfigSimple_Data::rules(int index) const {
  // @@protoc_insertion_point(field_get:mtproto.help_ConfigSimple_Data.rules)
  return rules_.Get(index);
}
inline ::mtproto::AccessPointRule* help_ConfigSimple_Data::mutable_rules(int index) {
  // @@protoc_insertion_point(field_mutable:mtproto.help_ConfigSimple_Data.rules)
  return rules_.Mutable(index);
}
inline ::mtproto::AccessPointRule* help_ConfigSimple_Data::add_rules() {
  // @@protoc_insertion_point(field_add:mtproto.help_ConfigSimple_Data.rules)
  return rules_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mtproto::AccessPointRule >*
help_ConfigSimple_Data::mutable_rules() {
  // @@protoc_insertion_point(field_mutable_list:mtproto.help_ConfigSimple_Data.rules)
  return &rules_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mtproto::AccessPointRule >&
help_ConfigSimple_Data::rules() const {
  // @@protoc_insertion_point(field_list:mtproto.help_ConfigSimple_Data.rules)
  return rules_;
}

// -------------------------------------------------------------------

// help_ConfigSimple

// .mtproto.TLConstructor constructor = 1;
inline void help_ConfigSimple::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor help_ConfigSimple::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.help_ConfigSimple.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void help_ConfigSimple::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.help_ConfigSimple.constructor)
}

// .mtproto.help_ConfigSimple_Data data2 = 2;
inline bool help_ConfigSimple::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void help_ConfigSimple::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::help_ConfigSimple_Data& help_ConfigSimple::data2() const {
  const ::mtproto::help_ConfigSimple_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.help_ConfigSimple.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::help_ConfigSimple_Data*>(
      &::mtproto::_help_ConfigSimple_Data_default_instance_);
}
inline ::mtproto::help_ConfigSimple_Data* help_ConfigSimple::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::help_ConfigSimple_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.help_ConfigSimple.data2)
  return data2_;
}
inline ::mtproto::help_ConfigSimple_Data* help_ConfigSimple::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.help_ConfigSimple.data2)
  
  ::mtproto::help_ConfigSimple_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void help_ConfigSimple::set_allocated_data2(::mtproto::help_ConfigSimple_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.help_ConfigSimple.data2)
}

// -------------------------------------------------------------------

// TL_help_configSimple

// .mtproto.help_ConfigSimple_Data data2 = 2;
inline bool TL_help_configSimple::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_help_configSimple::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::help_ConfigSimple_Data& TL_help_configSimple::data2() const {
  const ::mtproto::help_ConfigSimple_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_help_configSimple.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::help_ConfigSimple_Data*>(
      &::mtproto::_help_ConfigSimple_Data_default_instance_);
}
inline ::mtproto::help_ConfigSimple_Data* TL_help_configSimple::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::help_ConfigSimple_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_help_configSimple.data2)
  return data2_;
}
inline ::mtproto::help_ConfigSimple_Data* TL_help_configSimple::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_help_configSimple.data2)
  
  ::mtproto::help_ConfigSimple_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_help_configSimple::set_allocated_data2(::mtproto::help_ConfigSimple_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_help_configSimple.data2)
}

// -------------------------------------------------------------------

// MsgResendReq_Data

// repeated int64 msg_ids = 1;
inline int MsgResendReq_Data::msg_ids_size() const {
  return msg_ids_.size();
}
inline void MsgResendReq_Data::clear_msg_ids() {
  msg_ids_.Clear();
}
inline ::google::protobuf::int64 MsgResendReq_Data::msg_ids(int index) const {
  // @@protoc_insertion_point(field_get:mtproto.MsgResendReq_Data.msg_ids)
  return msg_ids_.Get(index);
}
inline void MsgResendReq_Data::set_msg_ids(int index, ::google::protobuf::int64 value) {
  msg_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:mtproto.MsgResendReq_Data.msg_ids)
}
inline void MsgResendReq_Data::add_msg_ids(::google::protobuf::int64 value) {
  msg_ids_.Add(value);
  // @@protoc_insertion_point(field_add:mtproto.MsgResendReq_Data.msg_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
MsgResendReq_Data::msg_ids() const {
  // @@protoc_insertion_point(field_list:mtproto.MsgResendReq_Data.msg_ids)
  return msg_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
MsgResendReq_Data::mutable_msg_ids() {
  // @@protoc_insertion_point(field_mutable_list:mtproto.MsgResendReq_Data.msg_ids)
  return &msg_ids_;
}

// -------------------------------------------------------------------

// MsgResendReq

// .mtproto.TLConstructor constructor = 1;
inline void MsgResendReq::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor MsgResendReq::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.MsgResendReq.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void MsgResendReq::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.MsgResendReq.constructor)
}

// .mtproto.MsgResendReq_Data data2 = 2;
inline bool MsgResendReq::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void MsgResendReq::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::MsgResendReq_Data& MsgResendReq::data2() const {
  const ::mtproto::MsgResendReq_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.MsgResendReq.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::MsgResendReq_Data*>(
      &::mtproto::_MsgResendReq_Data_default_instance_);
}
inline ::mtproto::MsgResendReq_Data* MsgResendReq::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::MsgResendReq_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.MsgResendReq.data2)
  return data2_;
}
inline ::mtproto::MsgResendReq_Data* MsgResendReq::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.MsgResendReq.data2)
  
  ::mtproto::MsgResendReq_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void MsgResendReq::set_allocated_data2(::mtproto::MsgResendReq_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.MsgResendReq.data2)
}

// -------------------------------------------------------------------

// TL_msg_resend_req

// .mtproto.MsgResendReq_Data data2 = 2;
inline bool TL_msg_resend_req::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_msg_resend_req::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::MsgResendReq_Data& TL_msg_resend_req::data2() const {
  const ::mtproto::MsgResendReq_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_msg_resend_req.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::MsgResendReq_Data*>(
      &::mtproto::_MsgResendReq_Data_default_instance_);
}
inline ::mtproto::MsgResendReq_Data* TL_msg_resend_req::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::MsgResendReq_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_msg_resend_req.data2)
  return data2_;
}
inline ::mtproto::MsgResendReq_Data* TL_msg_resend_req::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_msg_resend_req.data2)
  
  ::mtproto::MsgResendReq_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_msg_resend_req::set_allocated_data2(::mtproto::MsgResendReq_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_msg_resend_req.data2)
}

// -------------------------------------------------------------------

// NewSession_Data

// int64 first_msg_id = 1;
inline void NewSession_Data::clear_first_msg_id() {
  first_msg_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 NewSession_Data::first_msg_id() const {
  // @@protoc_insertion_point(field_get:mtproto.NewSession_Data.first_msg_id)
  return first_msg_id_;
}
inline void NewSession_Data::set_first_msg_id(::google::protobuf::int64 value) {
  
  first_msg_id_ = value;
  // @@protoc_insertion_point(field_set:mtproto.NewSession_Data.first_msg_id)
}

// int64 unique_id = 2;
inline void NewSession_Data::clear_unique_id() {
  unique_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 NewSession_Data::unique_id() const {
  // @@protoc_insertion_point(field_get:mtproto.NewSession_Data.unique_id)
  return unique_id_;
}
inline void NewSession_Data::set_unique_id(::google::protobuf::int64 value) {
  
  unique_id_ = value;
  // @@protoc_insertion_point(field_set:mtproto.NewSession_Data.unique_id)
}

// int64 server_salt = 3;
inline void NewSession_Data::clear_server_salt() {
  server_salt_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 NewSession_Data::server_salt() const {
  // @@protoc_insertion_point(field_get:mtproto.NewSession_Data.server_salt)
  return server_salt_;
}
inline void NewSession_Data::set_server_salt(::google::protobuf::int64 value) {
  
  server_salt_ = value;
  // @@protoc_insertion_point(field_set:mtproto.NewSession_Data.server_salt)
}

// -------------------------------------------------------------------

// NewSession

// .mtproto.TLConstructor constructor = 1;
inline void NewSession::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor NewSession::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.NewSession.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void NewSession::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.NewSession.constructor)
}

// .mtproto.NewSession_Data data2 = 2;
inline bool NewSession::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void NewSession::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::NewSession_Data& NewSession::data2() const {
  const ::mtproto::NewSession_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.NewSession.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::NewSession_Data*>(
      &::mtproto::_NewSession_Data_default_instance_);
}
inline ::mtproto::NewSession_Data* NewSession::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::NewSession_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.NewSession.data2)
  return data2_;
}
inline ::mtproto::NewSession_Data* NewSession::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.NewSession.data2)
  
  ::mtproto::NewSession_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void NewSession::set_allocated_data2(::mtproto::NewSession_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.NewSession.data2)
}

// -------------------------------------------------------------------

// TL_new_session_created

// .mtproto.NewSession_Data data2 = 2;
inline bool TL_new_session_created::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_new_session_created::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::NewSession_Data& TL_new_session_created::data2() const {
  const ::mtproto::NewSession_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_new_session_created.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::NewSession_Data*>(
      &::mtproto::_NewSession_Data_default_instance_);
}
inline ::mtproto::NewSession_Data* TL_new_session_created::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::NewSession_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_new_session_created.data2)
  return data2_;
}
inline ::mtproto::NewSession_Data* TL_new_session_created::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_new_session_created.data2)
  
  ::mtproto::NewSession_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_new_session_created::set_allocated_data2(::mtproto::NewSession_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_new_session_created.data2)
}

// -------------------------------------------------------------------

// IpPort_Data

// int32 ipv4 = 1;
inline void IpPort_Data::clear_ipv4() {
  ipv4_ = 0;
}
inline ::google::protobuf::int32 IpPort_Data::ipv4() const {
  // @@protoc_insertion_point(field_get:mtproto.IpPort_Data.ipv4)
  return ipv4_;
}
inline void IpPort_Data::set_ipv4(::google::protobuf::int32 value) {
  
  ipv4_ = value;
  // @@protoc_insertion_point(field_set:mtproto.IpPort_Data.ipv4)
}

// int32 port = 2;
inline void IpPort_Data::clear_port() {
  port_ = 0;
}
inline ::google::protobuf::int32 IpPort_Data::port() const {
  // @@protoc_insertion_point(field_get:mtproto.IpPort_Data.port)
  return port_;
}
inline void IpPort_Data::set_port(::google::protobuf::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:mtproto.IpPort_Data.port)
}

// bytes secret = 3;
inline void IpPort_Data::clear_secret() {
  secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IpPort_Data::secret() const {
  // @@protoc_insertion_point(field_get:mtproto.IpPort_Data.secret)
  return secret_.GetNoArena();
}
inline void IpPort_Data::set_secret(const ::std::string& value) {
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mtproto.IpPort_Data.secret)
}
#if LANG_CXX11
inline void IpPort_Data::set_secret(::std::string&& value) {
  
  secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mtproto.IpPort_Data.secret)
}
#endif
inline void IpPort_Data::set_secret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mtproto.IpPort_Data.secret)
}
inline void IpPort_Data::set_secret(const void* value, size_t size) {
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mtproto.IpPort_Data.secret)
}
inline ::std::string* IpPort_Data::mutable_secret() {
  
  // @@protoc_insertion_point(field_mutable:mtproto.IpPort_Data.secret)
  return secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IpPort_Data::release_secret() {
  // @@protoc_insertion_point(field_release:mtproto.IpPort_Data.secret)
  
  return secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IpPort_Data::set_allocated_secret(::std::string* secret) {
  if (secret != NULL) {
    
  } else {
    
  }
  secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secret);
  // @@protoc_insertion_point(field_set_allocated:mtproto.IpPort_Data.secret)
}

// -------------------------------------------------------------------

// IpPort

// .mtproto.TLConstructor constructor = 1;
inline void IpPort::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor IpPort::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.IpPort.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void IpPort::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.IpPort.constructor)
}

// .mtproto.IpPort_Data data2 = 2;
inline bool IpPort::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void IpPort::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::IpPort_Data& IpPort::data2() const {
  const ::mtproto::IpPort_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.IpPort.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::IpPort_Data*>(
      &::mtproto::_IpPort_Data_default_instance_);
}
inline ::mtproto::IpPort_Data* IpPort::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::IpPort_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.IpPort.data2)
  return data2_;
}
inline ::mtproto::IpPort_Data* IpPort::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.IpPort.data2)
  
  ::mtproto::IpPort_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void IpPort::set_allocated_data2(::mtproto::IpPort_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.IpPort.data2)
}

// -------------------------------------------------------------------

// TL_ipPort

// .mtproto.IpPort_Data data2 = 2;
inline bool TL_ipPort::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_ipPort::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::IpPort_Data& TL_ipPort::data2() const {
  const ::mtproto::IpPort_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_ipPort.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::IpPort_Data*>(
      &::mtproto::_IpPort_Data_default_instance_);
}
inline ::mtproto::IpPort_Data* TL_ipPort::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::IpPort_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_ipPort.data2)
  return data2_;
}
inline ::mtproto::IpPort_Data* TL_ipPort::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_ipPort.data2)
  
  ::mtproto::IpPort_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_ipPort::set_allocated_data2(::mtproto::IpPort_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_ipPort.data2)
}

// -------------------------------------------------------------------

// TL_ipPortSecret

// .mtproto.IpPort_Data data2 = 2;
inline bool TL_ipPortSecret::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_ipPortSecret::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::IpPort_Data& TL_ipPortSecret::data2() const {
  const ::mtproto::IpPort_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_ipPortSecret.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::IpPort_Data*>(
      &::mtproto::_IpPort_Data_default_instance_);
}
inline ::mtproto::IpPort_Data* TL_ipPortSecret::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::IpPort_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_ipPortSecret.data2)
  return data2_;
}
inline ::mtproto::IpPort_Data* TL_ipPortSecret::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_ipPortSecret.data2)
  
  ::mtproto::IpPort_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_ipPortSecret::set_allocated_data2(::mtproto::IpPort_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_ipPortSecret.data2)
}

// -------------------------------------------------------------------

// MsgsStateReq_Data

// repeated int64 msg_ids = 1;
inline int MsgsStateReq_Data::msg_ids_size() const {
  return msg_ids_.size();
}
inline void MsgsStateReq_Data::clear_msg_ids() {
  msg_ids_.Clear();
}
inline ::google::protobuf::int64 MsgsStateReq_Data::msg_ids(int index) const {
  // @@protoc_insertion_point(field_get:mtproto.MsgsStateReq_Data.msg_ids)
  return msg_ids_.Get(index);
}
inline void MsgsStateReq_Data::set_msg_ids(int index, ::google::protobuf::int64 value) {
  msg_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:mtproto.MsgsStateReq_Data.msg_ids)
}
inline void MsgsStateReq_Data::add_msg_ids(::google::protobuf::int64 value) {
  msg_ids_.Add(value);
  // @@protoc_insertion_point(field_add:mtproto.MsgsStateReq_Data.msg_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
MsgsStateReq_Data::msg_ids() const {
  // @@protoc_insertion_point(field_list:mtproto.MsgsStateReq_Data.msg_ids)
  return msg_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
MsgsStateReq_Data::mutable_msg_ids() {
  // @@protoc_insertion_point(field_mutable_list:mtproto.MsgsStateReq_Data.msg_ids)
  return &msg_ids_;
}

// -------------------------------------------------------------------

// MsgsStateReq

// .mtproto.TLConstructor constructor = 1;
inline void MsgsStateReq::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor MsgsStateReq::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.MsgsStateReq.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void MsgsStateReq::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.MsgsStateReq.constructor)
}

// .mtproto.MsgsStateReq_Data data2 = 2;
inline bool MsgsStateReq::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void MsgsStateReq::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::MsgsStateReq_Data& MsgsStateReq::data2() const {
  const ::mtproto::MsgsStateReq_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.MsgsStateReq.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::MsgsStateReq_Data*>(
      &::mtproto::_MsgsStateReq_Data_default_instance_);
}
inline ::mtproto::MsgsStateReq_Data* MsgsStateReq::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::MsgsStateReq_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.MsgsStateReq.data2)
  return data2_;
}
inline ::mtproto::MsgsStateReq_Data* MsgsStateReq::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.MsgsStateReq.data2)
  
  ::mtproto::MsgsStateReq_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void MsgsStateReq::set_allocated_data2(::mtproto::MsgsStateReq_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.MsgsStateReq.data2)
}

// -------------------------------------------------------------------

// TL_msgs_state_req

// .mtproto.MsgsStateReq_Data data2 = 2;
inline bool TL_msgs_state_req::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_msgs_state_req::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::MsgsStateReq_Data& TL_msgs_state_req::data2() const {
  const ::mtproto::MsgsStateReq_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_msgs_state_req.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::MsgsStateReq_Data*>(
      &::mtproto::_MsgsStateReq_Data_default_instance_);
}
inline ::mtproto::MsgsStateReq_Data* TL_msgs_state_req::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::MsgsStateReq_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_msgs_state_req.data2)
  return data2_;
}
inline ::mtproto::MsgsStateReq_Data* TL_msgs_state_req::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_msgs_state_req.data2)
  
  ::mtproto::MsgsStateReq_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_msgs_state_req::set_allocated_data2(::mtproto::MsgsStateReq_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_msgs_state_req.data2)
}

// -------------------------------------------------------------------

// MsgsStateInfo_Data

// int64 req_msg_id = 1;
inline void MsgsStateInfo_Data::clear_req_msg_id() {
  req_msg_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MsgsStateInfo_Data::req_msg_id() const {
  // @@protoc_insertion_point(field_get:mtproto.MsgsStateInfo_Data.req_msg_id)
  return req_msg_id_;
}
inline void MsgsStateInfo_Data::set_req_msg_id(::google::protobuf::int64 value) {
  
  req_msg_id_ = value;
  // @@protoc_insertion_point(field_set:mtproto.MsgsStateInfo_Data.req_msg_id)
}

// string info = 2;
inline void MsgsStateInfo_Data::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MsgsStateInfo_Data::info() const {
  // @@protoc_insertion_point(field_get:mtproto.MsgsStateInfo_Data.info)
  return info_.GetNoArena();
}
inline void MsgsStateInfo_Data::set_info(const ::std::string& value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mtproto.MsgsStateInfo_Data.info)
}
#if LANG_CXX11
inline void MsgsStateInfo_Data::set_info(::std::string&& value) {
  
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mtproto.MsgsStateInfo_Data.info)
}
#endif
inline void MsgsStateInfo_Data::set_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mtproto.MsgsStateInfo_Data.info)
}
inline void MsgsStateInfo_Data::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mtproto.MsgsStateInfo_Data.info)
}
inline ::std::string* MsgsStateInfo_Data::mutable_info() {
  
  // @@protoc_insertion_point(field_mutable:mtproto.MsgsStateInfo_Data.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MsgsStateInfo_Data::release_info() {
  // @@protoc_insertion_point(field_release:mtproto.MsgsStateInfo_Data.info)
  
  return info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MsgsStateInfo_Data::set_allocated_info(::std::string* info) {
  if (info != NULL) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:mtproto.MsgsStateInfo_Data.info)
}

// -------------------------------------------------------------------

// MsgsStateInfo

// .mtproto.TLConstructor constructor = 1;
inline void MsgsStateInfo::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor MsgsStateInfo::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.MsgsStateInfo.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void MsgsStateInfo::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.MsgsStateInfo.constructor)
}

// .mtproto.MsgsStateInfo_Data data2 = 2;
inline bool MsgsStateInfo::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void MsgsStateInfo::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::MsgsStateInfo_Data& MsgsStateInfo::data2() const {
  const ::mtproto::MsgsStateInfo_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.MsgsStateInfo.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::MsgsStateInfo_Data*>(
      &::mtproto::_MsgsStateInfo_Data_default_instance_);
}
inline ::mtproto::MsgsStateInfo_Data* MsgsStateInfo::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::MsgsStateInfo_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.MsgsStateInfo.data2)
  return data2_;
}
inline ::mtproto::MsgsStateInfo_Data* MsgsStateInfo::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.MsgsStateInfo.data2)
  
  ::mtproto::MsgsStateInfo_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void MsgsStateInfo::set_allocated_data2(::mtproto::MsgsStateInfo_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.MsgsStateInfo.data2)
}

// -------------------------------------------------------------------

// TL_msgs_state_info

// .mtproto.MsgsStateInfo_Data data2 = 2;
inline bool TL_msgs_state_info::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_msgs_state_info::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::MsgsStateInfo_Data& TL_msgs_state_info::data2() const {
  const ::mtproto::MsgsStateInfo_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_msgs_state_info.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::MsgsStateInfo_Data*>(
      &::mtproto::_MsgsStateInfo_Data_default_instance_);
}
inline ::mtproto::MsgsStateInfo_Data* TL_msgs_state_info::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::MsgsStateInfo_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_msgs_state_info.data2)
  return data2_;
}
inline ::mtproto::MsgsStateInfo_Data* TL_msgs_state_info::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_msgs_state_info.data2)
  
  ::mtproto::MsgsStateInfo_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_msgs_state_info::set_allocated_data2(::mtproto::MsgsStateInfo_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_msgs_state_info.data2)
}

// -------------------------------------------------------------------

// MsgsAllInfo_Data

// repeated int64 msg_ids = 1;
inline int MsgsAllInfo_Data::msg_ids_size() const {
  return msg_ids_.size();
}
inline void MsgsAllInfo_Data::clear_msg_ids() {
  msg_ids_.Clear();
}
inline ::google::protobuf::int64 MsgsAllInfo_Data::msg_ids(int index) const {
  // @@protoc_insertion_point(field_get:mtproto.MsgsAllInfo_Data.msg_ids)
  return msg_ids_.Get(index);
}
inline void MsgsAllInfo_Data::set_msg_ids(int index, ::google::protobuf::int64 value) {
  msg_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:mtproto.MsgsAllInfo_Data.msg_ids)
}
inline void MsgsAllInfo_Data::add_msg_ids(::google::protobuf::int64 value) {
  msg_ids_.Add(value);
  // @@protoc_insertion_point(field_add:mtproto.MsgsAllInfo_Data.msg_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
MsgsAllInfo_Data::msg_ids() const {
  // @@protoc_insertion_point(field_list:mtproto.MsgsAllInfo_Data.msg_ids)
  return msg_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
MsgsAllInfo_Data::mutable_msg_ids() {
  // @@protoc_insertion_point(field_mutable_list:mtproto.MsgsAllInfo_Data.msg_ids)
  return &msg_ids_;
}

// string info = 2;
inline void MsgsAllInfo_Data::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MsgsAllInfo_Data::info() const {
  // @@protoc_insertion_point(field_get:mtproto.MsgsAllInfo_Data.info)
  return info_.GetNoArena();
}
inline void MsgsAllInfo_Data::set_info(const ::std::string& value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mtproto.MsgsAllInfo_Data.info)
}
#if LANG_CXX11
inline void MsgsAllInfo_Data::set_info(::std::string&& value) {
  
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mtproto.MsgsAllInfo_Data.info)
}
#endif
inline void MsgsAllInfo_Data::set_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mtproto.MsgsAllInfo_Data.info)
}
inline void MsgsAllInfo_Data::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mtproto.MsgsAllInfo_Data.info)
}
inline ::std::string* MsgsAllInfo_Data::mutable_info() {
  
  // @@protoc_insertion_point(field_mutable:mtproto.MsgsAllInfo_Data.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MsgsAllInfo_Data::release_info() {
  // @@protoc_insertion_point(field_release:mtproto.MsgsAllInfo_Data.info)
  
  return info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MsgsAllInfo_Data::set_allocated_info(::std::string* info) {
  if (info != NULL) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:mtproto.MsgsAllInfo_Data.info)
}

// -------------------------------------------------------------------

// MsgsAllInfo

// .mtproto.TLConstructor constructor = 1;
inline void MsgsAllInfo::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor MsgsAllInfo::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.MsgsAllInfo.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void MsgsAllInfo::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.MsgsAllInfo.constructor)
}

// .mtproto.MsgsAllInfo_Data data2 = 2;
inline bool MsgsAllInfo::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void MsgsAllInfo::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::MsgsAllInfo_Data& MsgsAllInfo::data2() const {
  const ::mtproto::MsgsAllInfo_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.MsgsAllInfo.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::MsgsAllInfo_Data*>(
      &::mtproto::_MsgsAllInfo_Data_default_instance_);
}
inline ::mtproto::MsgsAllInfo_Data* MsgsAllInfo::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::MsgsAllInfo_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.MsgsAllInfo.data2)
  return data2_;
}
inline ::mtproto::MsgsAllInfo_Data* MsgsAllInfo::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.MsgsAllInfo.data2)
  
  ::mtproto::MsgsAllInfo_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void MsgsAllInfo::set_allocated_data2(::mtproto::MsgsAllInfo_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.MsgsAllInfo.data2)
}

// -------------------------------------------------------------------

// TL_msgs_all_info

// .mtproto.MsgsAllInfo_Data data2 = 2;
inline bool TL_msgs_all_info::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_msgs_all_info::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::MsgsAllInfo_Data& TL_msgs_all_info::data2() const {
  const ::mtproto::MsgsAllInfo_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_msgs_all_info.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::MsgsAllInfo_Data*>(
      &::mtproto::_MsgsAllInfo_Data_default_instance_);
}
inline ::mtproto::MsgsAllInfo_Data* TL_msgs_all_info::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::MsgsAllInfo_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_msgs_all_info.data2)
  return data2_;
}
inline ::mtproto::MsgsAllInfo_Data* TL_msgs_all_info::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_msgs_all_info.data2)
  
  ::mtproto::MsgsAllInfo_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_msgs_all_info::set_allocated_data2(::mtproto::MsgsAllInfo_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_msgs_all_info.data2)
}

// -------------------------------------------------------------------

// MsgDetailedInfo_Data

// int64 msg_id = 1;
inline void MsgDetailedInfo_Data::clear_msg_id() {
  msg_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MsgDetailedInfo_Data::msg_id() const {
  // @@protoc_insertion_point(field_get:mtproto.MsgDetailedInfo_Data.msg_id)
  return msg_id_;
}
inline void MsgDetailedInfo_Data::set_msg_id(::google::protobuf::int64 value) {
  
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:mtproto.MsgDetailedInfo_Data.msg_id)
}

// int64 answer_msg_id = 2;
inline void MsgDetailedInfo_Data::clear_answer_msg_id() {
  answer_msg_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MsgDetailedInfo_Data::answer_msg_id() const {
  // @@protoc_insertion_point(field_get:mtproto.MsgDetailedInfo_Data.answer_msg_id)
  return answer_msg_id_;
}
inline void MsgDetailedInfo_Data::set_answer_msg_id(::google::protobuf::int64 value) {
  
  answer_msg_id_ = value;
  // @@protoc_insertion_point(field_set:mtproto.MsgDetailedInfo_Data.answer_msg_id)
}

// int32 bytes = 3;
inline void MsgDetailedInfo_Data::clear_bytes() {
  bytes_ = 0;
}
inline ::google::protobuf::int32 MsgDetailedInfo_Data::bytes() const {
  // @@protoc_insertion_point(field_get:mtproto.MsgDetailedInfo_Data.bytes)
  return bytes_;
}
inline void MsgDetailedInfo_Data::set_bytes(::google::protobuf::int32 value) {
  
  bytes_ = value;
  // @@protoc_insertion_point(field_set:mtproto.MsgDetailedInfo_Data.bytes)
}

// int32 status = 4;
inline void MsgDetailedInfo_Data::clear_status() {
  status_ = 0;
}
inline ::google::protobuf::int32 MsgDetailedInfo_Data::status() const {
  // @@protoc_insertion_point(field_get:mtproto.MsgDetailedInfo_Data.status)
  return status_;
}
inline void MsgDetailedInfo_Data::set_status(::google::protobuf::int32 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:mtproto.MsgDetailedInfo_Data.status)
}

// -------------------------------------------------------------------

// MsgDetailedInfo

// .mtproto.TLConstructor constructor = 1;
inline void MsgDetailedInfo::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor MsgDetailedInfo::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.MsgDetailedInfo.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void MsgDetailedInfo::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.MsgDetailedInfo.constructor)
}

// .mtproto.MsgDetailedInfo_Data data2 = 2;
inline bool MsgDetailedInfo::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void MsgDetailedInfo::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::MsgDetailedInfo_Data& MsgDetailedInfo::data2() const {
  const ::mtproto::MsgDetailedInfo_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.MsgDetailedInfo.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::MsgDetailedInfo_Data*>(
      &::mtproto::_MsgDetailedInfo_Data_default_instance_);
}
inline ::mtproto::MsgDetailedInfo_Data* MsgDetailedInfo::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::MsgDetailedInfo_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.MsgDetailedInfo.data2)
  return data2_;
}
inline ::mtproto::MsgDetailedInfo_Data* MsgDetailedInfo::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.MsgDetailedInfo.data2)
  
  ::mtproto::MsgDetailedInfo_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void MsgDetailedInfo::set_allocated_data2(::mtproto::MsgDetailedInfo_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.MsgDetailedInfo.data2)
}

// -------------------------------------------------------------------

// TL_msg_detailed_info

// .mtproto.MsgDetailedInfo_Data data2 = 2;
inline bool TL_msg_detailed_info::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_msg_detailed_info::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::MsgDetailedInfo_Data& TL_msg_detailed_info::data2() const {
  const ::mtproto::MsgDetailedInfo_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_msg_detailed_info.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::MsgDetailedInfo_Data*>(
      &::mtproto::_MsgDetailedInfo_Data_default_instance_);
}
inline ::mtproto::MsgDetailedInfo_Data* TL_msg_detailed_info::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::MsgDetailedInfo_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_msg_detailed_info.data2)
  return data2_;
}
inline ::mtproto::MsgDetailedInfo_Data* TL_msg_detailed_info::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_msg_detailed_info.data2)
  
  ::mtproto::MsgDetailedInfo_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_msg_detailed_info::set_allocated_data2(::mtproto::MsgDetailedInfo_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_msg_detailed_info.data2)
}

// -------------------------------------------------------------------

// TL_msg_new_detailed_info

// .mtproto.MsgDetailedInfo_Data data2 = 2;
inline bool TL_msg_new_detailed_info::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_msg_new_detailed_info::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::MsgDetailedInfo_Data& TL_msg_new_detailed_info::data2() const {
  const ::mtproto::MsgDetailedInfo_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_msg_new_detailed_info.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::MsgDetailedInfo_Data*>(
      &::mtproto::_MsgDetailedInfo_Data_default_instance_);
}
inline ::mtproto::MsgDetailedInfo_Data* TL_msg_new_detailed_info::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::MsgDetailedInfo_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_msg_new_detailed_info.data2)
  return data2_;
}
inline ::mtproto::MsgDetailedInfo_Data* TL_msg_new_detailed_info::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_msg_new_detailed_info.data2)
  
  ::mtproto::MsgDetailedInfo_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_msg_new_detailed_info::set_allocated_data2(::mtproto::MsgDetailedInfo_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_msg_new_detailed_info.data2)
}

// -------------------------------------------------------------------

// AccessPointRule_Data

// string phone_prefix_rules = 1;
inline void AccessPointRule_Data::clear_phone_prefix_rules() {
  phone_prefix_rules_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessPointRule_Data::phone_prefix_rules() const {
  // @@protoc_insertion_point(field_get:mtproto.AccessPointRule_Data.phone_prefix_rules)
  return phone_prefix_rules_.GetNoArena();
}
inline void AccessPointRule_Data::set_phone_prefix_rules(const ::std::string& value) {
  
  phone_prefix_rules_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mtproto.AccessPointRule_Data.phone_prefix_rules)
}
#if LANG_CXX11
inline void AccessPointRule_Data::set_phone_prefix_rules(::std::string&& value) {
  
  phone_prefix_rules_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mtproto.AccessPointRule_Data.phone_prefix_rules)
}
#endif
inline void AccessPointRule_Data::set_phone_prefix_rules(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  phone_prefix_rules_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mtproto.AccessPointRule_Data.phone_prefix_rules)
}
inline void AccessPointRule_Data::set_phone_prefix_rules(const char* value, size_t size) {
  
  phone_prefix_rules_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mtproto.AccessPointRule_Data.phone_prefix_rules)
}
inline ::std::string* AccessPointRule_Data::mutable_phone_prefix_rules() {
  
  // @@protoc_insertion_point(field_mutable:mtproto.AccessPointRule_Data.phone_prefix_rules)
  return phone_prefix_rules_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessPointRule_Data::release_phone_prefix_rules() {
  // @@protoc_insertion_point(field_release:mtproto.AccessPointRule_Data.phone_prefix_rules)
  
  return phone_prefix_rules_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessPointRule_Data::set_allocated_phone_prefix_rules(::std::string* phone_prefix_rules) {
  if (phone_prefix_rules != NULL) {
    
  } else {
    
  }
  phone_prefix_rules_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), phone_prefix_rules);
  // @@protoc_insertion_point(field_set_allocated:mtproto.AccessPointRule_Data.phone_prefix_rules)
}

// int32 dc_id = 2;
inline void AccessPointRule_Data::clear_dc_id() {
  dc_id_ = 0;
}
inline ::google::protobuf::int32 AccessPointRule_Data::dc_id() const {
  // @@protoc_insertion_point(field_get:mtproto.AccessPointRule_Data.dc_id)
  return dc_id_;
}
inline void AccessPointRule_Data::set_dc_id(::google::protobuf::int32 value) {
  
  dc_id_ = value;
  // @@protoc_insertion_point(field_set:mtproto.AccessPointRule_Data.dc_id)
}

// repeated .mtproto.IpPort ips = 3;
inline int AccessPointRule_Data::ips_size() const {
  return ips_.size();
}
inline void AccessPointRule_Data::clear_ips() {
  ips_.Clear();
}
inline const ::mtproto::IpPort& AccessPointRule_Data::ips(int index) const {
  // @@protoc_insertion_point(field_get:mtproto.AccessPointRule_Data.ips)
  return ips_.Get(index);
}
inline ::mtproto::IpPort* AccessPointRule_Data::mutable_ips(int index) {
  // @@protoc_insertion_point(field_mutable:mtproto.AccessPointRule_Data.ips)
  return ips_.Mutable(index);
}
inline ::mtproto::IpPort* AccessPointRule_Data::add_ips() {
  // @@protoc_insertion_point(field_add:mtproto.AccessPointRule_Data.ips)
  return ips_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mtproto::IpPort >*
AccessPointRule_Data::mutable_ips() {
  // @@protoc_insertion_point(field_mutable_list:mtproto.AccessPointRule_Data.ips)
  return &ips_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mtproto::IpPort >&
AccessPointRule_Data::ips() const {
  // @@protoc_insertion_point(field_list:mtproto.AccessPointRule_Data.ips)
  return ips_;
}

// -------------------------------------------------------------------

// AccessPointRule

// .mtproto.TLConstructor constructor = 1;
inline void AccessPointRule::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor AccessPointRule::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.AccessPointRule.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void AccessPointRule::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.AccessPointRule.constructor)
}

// .mtproto.AccessPointRule_Data data2 = 2;
inline bool AccessPointRule::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void AccessPointRule::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::AccessPointRule_Data& AccessPointRule::data2() const {
  const ::mtproto::AccessPointRule_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.AccessPointRule.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::AccessPointRule_Data*>(
      &::mtproto::_AccessPointRule_Data_default_instance_);
}
inline ::mtproto::AccessPointRule_Data* AccessPointRule::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::AccessPointRule_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.AccessPointRule.data2)
  return data2_;
}
inline ::mtproto::AccessPointRule_Data* AccessPointRule::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.AccessPointRule.data2)
  
  ::mtproto::AccessPointRule_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void AccessPointRule::set_allocated_data2(::mtproto::AccessPointRule_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.AccessPointRule.data2)
}

// -------------------------------------------------------------------

// TL_accessPointRule

// .mtproto.AccessPointRule_Data data2 = 2;
inline bool TL_accessPointRule::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_accessPointRule::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::AccessPointRule_Data& TL_accessPointRule::data2() const {
  const ::mtproto::AccessPointRule_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_accessPointRule.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::AccessPointRule_Data*>(
      &::mtproto::_AccessPointRule_Data_default_instance_);
}
inline ::mtproto::AccessPointRule_Data* TL_accessPointRule::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::AccessPointRule_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_accessPointRule.data2)
  return data2_;
}
inline ::mtproto::AccessPointRule_Data* TL_accessPointRule::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_accessPointRule.data2)
  
  ::mtproto::AccessPointRule_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_accessPointRule::set_allocated_data2(::mtproto::AccessPointRule_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_accessPointRule.data2)
}

// -------------------------------------------------------------------

// RpcDropAnswer_Data

// int64 msg_id = 1;
inline void RpcDropAnswer_Data::clear_msg_id() {
  msg_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RpcDropAnswer_Data::msg_id() const {
  // @@protoc_insertion_point(field_get:mtproto.RpcDropAnswer_Data.msg_id)
  return msg_id_;
}
inline void RpcDropAnswer_Data::set_msg_id(::google::protobuf::int64 value) {
  
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:mtproto.RpcDropAnswer_Data.msg_id)
}

// int32 seq_no = 2;
inline void RpcDropAnswer_Data::clear_seq_no() {
  seq_no_ = 0;
}
inline ::google::protobuf::int32 RpcDropAnswer_Data::seq_no() const {
  // @@protoc_insertion_point(field_get:mtproto.RpcDropAnswer_Data.seq_no)
  return seq_no_;
}
inline void RpcDropAnswer_Data::set_seq_no(::google::protobuf::int32 value) {
  
  seq_no_ = value;
  // @@protoc_insertion_point(field_set:mtproto.RpcDropAnswer_Data.seq_no)
}

// int32 bytes = 3;
inline void RpcDropAnswer_Data::clear_bytes() {
  bytes_ = 0;
}
inline ::google::protobuf::int32 RpcDropAnswer_Data::bytes() const {
  // @@protoc_insertion_point(field_get:mtproto.RpcDropAnswer_Data.bytes)
  return bytes_;
}
inline void RpcDropAnswer_Data::set_bytes(::google::protobuf::int32 value) {
  
  bytes_ = value;
  // @@protoc_insertion_point(field_set:mtproto.RpcDropAnswer_Data.bytes)
}

// -------------------------------------------------------------------

// RpcDropAnswer

// .mtproto.TLConstructor constructor = 1;
inline void RpcDropAnswer::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor RpcDropAnswer::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.RpcDropAnswer.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void RpcDropAnswer::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.RpcDropAnswer.constructor)
}

// .mtproto.RpcDropAnswer_Data data2 = 2;
inline bool RpcDropAnswer::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void RpcDropAnswer::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::RpcDropAnswer_Data& RpcDropAnswer::data2() const {
  const ::mtproto::RpcDropAnswer_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.RpcDropAnswer.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::RpcDropAnswer_Data*>(
      &::mtproto::_RpcDropAnswer_Data_default_instance_);
}
inline ::mtproto::RpcDropAnswer_Data* RpcDropAnswer::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::RpcDropAnswer_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.RpcDropAnswer.data2)
  return data2_;
}
inline ::mtproto::RpcDropAnswer_Data* RpcDropAnswer::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.RpcDropAnswer.data2)
  
  ::mtproto::RpcDropAnswer_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void RpcDropAnswer::set_allocated_data2(::mtproto::RpcDropAnswer_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.RpcDropAnswer.data2)
}

// -------------------------------------------------------------------

// TL_rpc_answer_unknown

// .mtproto.RpcDropAnswer_Data data2 = 2;
inline bool TL_rpc_answer_unknown::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_rpc_answer_unknown::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::RpcDropAnswer_Data& TL_rpc_answer_unknown::data2() const {
  const ::mtproto::RpcDropAnswer_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_rpc_answer_unknown.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::RpcDropAnswer_Data*>(
      &::mtproto::_RpcDropAnswer_Data_default_instance_);
}
inline ::mtproto::RpcDropAnswer_Data* TL_rpc_answer_unknown::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::RpcDropAnswer_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_rpc_answer_unknown.data2)
  return data2_;
}
inline ::mtproto::RpcDropAnswer_Data* TL_rpc_answer_unknown::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_rpc_answer_unknown.data2)
  
  ::mtproto::RpcDropAnswer_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_rpc_answer_unknown::set_allocated_data2(::mtproto::RpcDropAnswer_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_rpc_answer_unknown.data2)
}

// -------------------------------------------------------------------

// TL_rpc_answer_dropped_running

// .mtproto.RpcDropAnswer_Data data2 = 2;
inline bool TL_rpc_answer_dropped_running::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_rpc_answer_dropped_running::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::RpcDropAnswer_Data& TL_rpc_answer_dropped_running::data2() const {
  const ::mtproto::RpcDropAnswer_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_rpc_answer_dropped_running.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::RpcDropAnswer_Data*>(
      &::mtproto::_RpcDropAnswer_Data_default_instance_);
}
inline ::mtproto::RpcDropAnswer_Data* TL_rpc_answer_dropped_running::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::RpcDropAnswer_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_rpc_answer_dropped_running.data2)
  return data2_;
}
inline ::mtproto::RpcDropAnswer_Data* TL_rpc_answer_dropped_running::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_rpc_answer_dropped_running.data2)
  
  ::mtproto::RpcDropAnswer_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_rpc_answer_dropped_running::set_allocated_data2(::mtproto::RpcDropAnswer_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_rpc_answer_dropped_running.data2)
}

// -------------------------------------------------------------------

// TL_rpc_answer_dropped

// .mtproto.RpcDropAnswer_Data data2 = 2;
inline bool TL_rpc_answer_dropped::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_rpc_answer_dropped::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::RpcDropAnswer_Data& TL_rpc_answer_dropped::data2() const {
  const ::mtproto::RpcDropAnswer_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_rpc_answer_dropped.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::RpcDropAnswer_Data*>(
      &::mtproto::_RpcDropAnswer_Data_default_instance_);
}
inline ::mtproto::RpcDropAnswer_Data* TL_rpc_answer_dropped::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::RpcDropAnswer_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_rpc_answer_dropped.data2)
  return data2_;
}
inline ::mtproto::RpcDropAnswer_Data* TL_rpc_answer_dropped::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_rpc_answer_dropped.data2)
  
  ::mtproto::RpcDropAnswer_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_rpc_answer_dropped::set_allocated_data2(::mtproto::RpcDropAnswer_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_rpc_answer_dropped.data2)
}

// -------------------------------------------------------------------

// Pong_Data

// int64 msg_id = 1;
inline void Pong_Data::clear_msg_id() {
  msg_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Pong_Data::msg_id() const {
  // @@protoc_insertion_point(field_get:mtproto.Pong_Data.msg_id)
  return msg_id_;
}
inline void Pong_Data::set_msg_id(::google::protobuf::int64 value) {
  
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:mtproto.Pong_Data.msg_id)
}

// int64 ping_id = 2;
inline void Pong_Data::clear_ping_id() {
  ping_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Pong_Data::ping_id() const {
  // @@protoc_insertion_point(field_get:mtproto.Pong_Data.ping_id)
  return ping_id_;
}
inline void Pong_Data::set_ping_id(::google::protobuf::int64 value) {
  
  ping_id_ = value;
  // @@protoc_insertion_point(field_set:mtproto.Pong_Data.ping_id)
}

// -------------------------------------------------------------------

// Pong

// .mtproto.TLConstructor constructor = 1;
inline void Pong::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor Pong::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.Pong.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void Pong::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.Pong.constructor)
}

// .mtproto.Pong_Data data2 = 2;
inline bool Pong::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void Pong::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::Pong_Data& Pong::data2() const {
  const ::mtproto::Pong_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.Pong.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::Pong_Data*>(
      &::mtproto::_Pong_Data_default_instance_);
}
inline ::mtproto::Pong_Data* Pong::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::Pong_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.Pong.data2)
  return data2_;
}
inline ::mtproto::Pong_Data* Pong::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.Pong.data2)
  
  ::mtproto::Pong_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void Pong::set_allocated_data2(::mtproto::Pong_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.Pong.data2)
}

// -------------------------------------------------------------------

// TL_pong

// .mtproto.Pong_Data data2 = 2;
inline bool TL_pong::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_pong::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::Pong_Data& TL_pong::data2() const {
  const ::mtproto::Pong_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_pong.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::Pong_Data*>(
      &::mtproto::_Pong_Data_default_instance_);
}
inline ::mtproto::Pong_Data* TL_pong::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::Pong_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_pong.data2)
  return data2_;
}
inline ::mtproto::Pong_Data* TL_pong::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_pong.data2)
  
  ::mtproto::Pong_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_pong::set_allocated_data2(::mtproto::Pong_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_pong.data2)
}

// -------------------------------------------------------------------

// DestroySessionRes_Data

// int64 session_id = 1;
inline void DestroySessionRes_Data::clear_session_id() {
  session_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 DestroySessionRes_Data::session_id() const {
  // @@protoc_insertion_point(field_get:mtproto.DestroySessionRes_Data.session_id)
  return session_id_;
}
inline void DestroySessionRes_Data::set_session_id(::google::protobuf::int64 value) {
  
  session_id_ = value;
  // @@protoc_insertion_point(field_set:mtproto.DestroySessionRes_Data.session_id)
}

// -------------------------------------------------------------------

// DestroySessionRes

// .mtproto.TLConstructor constructor = 1;
inline void DestroySessionRes::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor DestroySessionRes::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.DestroySessionRes.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void DestroySessionRes::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.DestroySessionRes.constructor)
}

// .mtproto.DestroySessionRes_Data data2 = 2;
inline bool DestroySessionRes::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void DestroySessionRes::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::DestroySessionRes_Data& DestroySessionRes::data2() const {
  const ::mtproto::DestroySessionRes_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.DestroySessionRes.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::DestroySessionRes_Data*>(
      &::mtproto::_DestroySessionRes_Data_default_instance_);
}
inline ::mtproto::DestroySessionRes_Data* DestroySessionRes::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::DestroySessionRes_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.DestroySessionRes.data2)
  return data2_;
}
inline ::mtproto::DestroySessionRes_Data* DestroySessionRes::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.DestroySessionRes.data2)
  
  ::mtproto::DestroySessionRes_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void DestroySessionRes::set_allocated_data2(::mtproto::DestroySessionRes_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.DestroySessionRes.data2)
}

// -------------------------------------------------------------------

// TL_destroy_session_ok

// .mtproto.DestroySessionRes_Data data2 = 2;
inline bool TL_destroy_session_ok::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_destroy_session_ok::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::DestroySessionRes_Data& TL_destroy_session_ok::data2() const {
  const ::mtproto::DestroySessionRes_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_destroy_session_ok.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::DestroySessionRes_Data*>(
      &::mtproto::_DestroySessionRes_Data_default_instance_);
}
inline ::mtproto::DestroySessionRes_Data* TL_destroy_session_ok::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::DestroySessionRes_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_destroy_session_ok.data2)
  return data2_;
}
inline ::mtproto::DestroySessionRes_Data* TL_destroy_session_ok::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_destroy_session_ok.data2)
  
  ::mtproto::DestroySessionRes_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_destroy_session_ok::set_allocated_data2(::mtproto::DestroySessionRes_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_destroy_session_ok.data2)
}

// -------------------------------------------------------------------

// TL_destroy_session_none

// .mtproto.DestroySessionRes_Data data2 = 2;
inline bool TL_destroy_session_none::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_destroy_session_none::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::DestroySessionRes_Data& TL_destroy_session_none::data2() const {
  const ::mtproto::DestroySessionRes_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_destroy_session_none.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::DestroySessionRes_Data*>(
      &::mtproto::_DestroySessionRes_Data_default_instance_);
}
inline ::mtproto::DestroySessionRes_Data* TL_destroy_session_none::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::DestroySessionRes_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_destroy_session_none.data2)
  return data2_;
}
inline ::mtproto::DestroySessionRes_Data* TL_destroy_session_none::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_destroy_session_none.data2)
  
  ::mtproto::DestroySessionRes_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_destroy_session_none::set_allocated_data2(::mtproto::DestroySessionRes_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_destroy_session_none.data2)
}

// -------------------------------------------------------------------

// HttpWait_Data

// int32 max_delay = 1;
inline void HttpWait_Data::clear_max_delay() {
  max_delay_ = 0;
}
inline ::google::protobuf::int32 HttpWait_Data::max_delay() const {
  // @@protoc_insertion_point(field_get:mtproto.HttpWait_Data.max_delay)
  return max_delay_;
}
inline void HttpWait_Data::set_max_delay(::google::protobuf::int32 value) {
  
  max_delay_ = value;
  // @@protoc_insertion_point(field_set:mtproto.HttpWait_Data.max_delay)
}

// int32 wait_after = 2;
inline void HttpWait_Data::clear_wait_after() {
  wait_after_ = 0;
}
inline ::google::protobuf::int32 HttpWait_Data::wait_after() const {
  // @@protoc_insertion_point(field_get:mtproto.HttpWait_Data.wait_after)
  return wait_after_;
}
inline void HttpWait_Data::set_wait_after(::google::protobuf::int32 value) {
  
  wait_after_ = value;
  // @@protoc_insertion_point(field_set:mtproto.HttpWait_Data.wait_after)
}

// int32 max_wait = 3;
inline void HttpWait_Data::clear_max_wait() {
  max_wait_ = 0;
}
inline ::google::protobuf::int32 HttpWait_Data::max_wait() const {
  // @@protoc_insertion_point(field_get:mtproto.HttpWait_Data.max_wait)
  return max_wait_;
}
inline void HttpWait_Data::set_max_wait(::google::protobuf::int32 value) {
  
  max_wait_ = value;
  // @@protoc_insertion_point(field_set:mtproto.HttpWait_Data.max_wait)
}

// -------------------------------------------------------------------

// HttpWait

// .mtproto.TLConstructor constructor = 1;
inline void HttpWait::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor HttpWait::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.HttpWait.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void HttpWait::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.HttpWait.constructor)
}

// .mtproto.HttpWait_Data data2 = 2;
inline bool HttpWait::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void HttpWait::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::HttpWait_Data& HttpWait::data2() const {
  const ::mtproto::HttpWait_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.HttpWait.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::HttpWait_Data*>(
      &::mtproto::_HttpWait_Data_default_instance_);
}
inline ::mtproto::HttpWait_Data* HttpWait::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::HttpWait_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.HttpWait.data2)
  return data2_;
}
inline ::mtproto::HttpWait_Data* HttpWait::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.HttpWait.data2)
  
  ::mtproto::HttpWait_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void HttpWait::set_allocated_data2(::mtproto::HttpWait_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.HttpWait.data2)
}

// -------------------------------------------------------------------

// TL_http_wait

// .mtproto.HttpWait_Data data2 = 2;
inline bool TL_http_wait::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_http_wait::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::HttpWait_Data& TL_http_wait::data2() const {
  const ::mtproto::HttpWait_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_http_wait.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::HttpWait_Data*>(
      &::mtproto::_HttpWait_Data_default_instance_);
}
inline ::mtproto::HttpWait_Data* TL_http_wait::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::HttpWait_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_http_wait.data2)
  return data2_;
}
inline ::mtproto::HttpWait_Data* TL_http_wait::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_http_wait.data2)
  
  ::mtproto::HttpWait_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_http_wait::set_allocated_data2(::mtproto::HttpWait_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_http_wait.data2)
}

// -------------------------------------------------------------------

// RpcError_Data

// int32 error_code = 1;
inline void RpcError_Data::clear_error_code() {
  error_code_ = 0;
}
inline ::google::protobuf::int32 RpcError_Data::error_code() const {
  // @@protoc_insertion_point(field_get:mtproto.RpcError_Data.error_code)
  return error_code_;
}
inline void RpcError_Data::set_error_code(::google::protobuf::int32 value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:mtproto.RpcError_Data.error_code)
}

// string error_message = 2;
inline void RpcError_Data::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RpcError_Data::error_message() const {
  // @@protoc_insertion_point(field_get:mtproto.RpcError_Data.error_message)
  return error_message_.GetNoArena();
}
inline void RpcError_Data::set_error_message(const ::std::string& value) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mtproto.RpcError_Data.error_message)
}
#if LANG_CXX11
inline void RpcError_Data::set_error_message(::std::string&& value) {
  
  error_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mtproto.RpcError_Data.error_message)
}
#endif
inline void RpcError_Data::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mtproto.RpcError_Data.error_message)
}
inline void RpcError_Data::set_error_message(const char* value, size_t size) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mtproto.RpcError_Data.error_message)
}
inline ::std::string* RpcError_Data::mutable_error_message() {
  
  // @@protoc_insertion_point(field_mutable:mtproto.RpcError_Data.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcError_Data::release_error_message() {
  // @@protoc_insertion_point(field_release:mtproto.RpcError_Data.error_message)
  
  return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcError_Data::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    
  } else {
    
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:mtproto.RpcError_Data.error_message)
}

// -------------------------------------------------------------------

// RpcError

// .mtproto.TLConstructor constructor = 1;
inline void RpcError::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor RpcError::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.RpcError.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void RpcError::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.RpcError.constructor)
}

// .mtproto.RpcError_Data data2 = 2;
inline bool RpcError::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void RpcError::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::RpcError_Data& RpcError::data2() const {
  const ::mtproto::RpcError_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.RpcError.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::RpcError_Data*>(
      &::mtproto::_RpcError_Data_default_instance_);
}
inline ::mtproto::RpcError_Data* RpcError::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::RpcError_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.RpcError.data2)
  return data2_;
}
inline ::mtproto::RpcError_Data* RpcError::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.RpcError.data2)
  
  ::mtproto::RpcError_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void RpcError::set_allocated_data2(::mtproto::RpcError_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.RpcError.data2)
}

// -------------------------------------------------------------------

// TL_rpc_error

// .mtproto.RpcError_Data data2 = 2;
inline bool TL_rpc_error::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_rpc_error::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::RpcError_Data& TL_rpc_error::data2() const {
  const ::mtproto::RpcError_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_rpc_error.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::RpcError_Data*>(
      &::mtproto::_RpcError_Data_default_instance_);
}
inline ::mtproto::RpcError_Data* TL_rpc_error::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::RpcError_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_rpc_error.data2)
  return data2_;
}
inline ::mtproto::RpcError_Data* TL_rpc_error::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_rpc_error.data2)
  
  ::mtproto::RpcError_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_rpc_error::set_allocated_data2(::mtproto::RpcError_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_rpc_error.data2)
}

// -------------------------------------------------------------------

// FutureSalts_Data

// int64 req_msg_id = 1;
inline void FutureSalts_Data::clear_req_msg_id() {
  req_msg_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 FutureSalts_Data::req_msg_id() const {
  // @@protoc_insertion_point(field_get:mtproto.FutureSalts_Data.req_msg_id)
  return req_msg_id_;
}
inline void FutureSalts_Data::set_req_msg_id(::google::protobuf::int64 value) {
  
  req_msg_id_ = value;
  // @@protoc_insertion_point(field_set:mtproto.FutureSalts_Data.req_msg_id)
}

// int32 now = 2;
inline void FutureSalts_Data::clear_now() {
  now_ = 0;
}
inline ::google::protobuf::int32 FutureSalts_Data::now() const {
  // @@protoc_insertion_point(field_get:mtproto.FutureSalts_Data.now)
  return now_;
}
inline void FutureSalts_Data::set_now(::google::protobuf::int32 value) {
  
  now_ = value;
  // @@protoc_insertion_point(field_set:mtproto.FutureSalts_Data.now)
}

// repeated .mtproto.TL_future_salt salts = 3;
inline int FutureSalts_Data::salts_size() const {
  return salts_.size();
}
inline void FutureSalts_Data::clear_salts() {
  salts_.Clear();
}
inline const ::mtproto::TL_future_salt& FutureSalts_Data::salts(int index) const {
  // @@protoc_insertion_point(field_get:mtproto.FutureSalts_Data.salts)
  return salts_.Get(index);
}
inline ::mtproto::TL_future_salt* FutureSalts_Data::mutable_salts(int index) {
  // @@protoc_insertion_point(field_mutable:mtproto.FutureSalts_Data.salts)
  return salts_.Mutable(index);
}
inline ::mtproto::TL_future_salt* FutureSalts_Data::add_salts() {
  // @@protoc_insertion_point(field_add:mtproto.FutureSalts_Data.salts)
  return salts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mtproto::TL_future_salt >*
FutureSalts_Data::mutable_salts() {
  // @@protoc_insertion_point(field_mutable_list:mtproto.FutureSalts_Data.salts)
  return &salts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mtproto::TL_future_salt >&
FutureSalts_Data::salts() const {
  // @@protoc_insertion_point(field_list:mtproto.FutureSalts_Data.salts)
  return salts_;
}

// -------------------------------------------------------------------

// FutureSalts

// .mtproto.TLConstructor constructor = 1;
inline void FutureSalts::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor FutureSalts::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.FutureSalts.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void FutureSalts::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.FutureSalts.constructor)
}

// .mtproto.FutureSalts_Data data2 = 2;
inline bool FutureSalts::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void FutureSalts::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::FutureSalts_Data& FutureSalts::data2() const {
  const ::mtproto::FutureSalts_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.FutureSalts.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::FutureSalts_Data*>(
      &::mtproto::_FutureSalts_Data_default_instance_);
}
inline ::mtproto::FutureSalts_Data* FutureSalts::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::FutureSalts_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.FutureSalts.data2)
  return data2_;
}
inline ::mtproto::FutureSalts_Data* FutureSalts::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.FutureSalts.data2)
  
  ::mtproto::FutureSalts_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void FutureSalts::set_allocated_data2(::mtproto::FutureSalts_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.FutureSalts.data2)
}

// -------------------------------------------------------------------

// TL_future_salts

// .mtproto.FutureSalts_Data data2 = 2;
inline bool TL_future_salts::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_future_salts::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::FutureSalts_Data& TL_future_salts::data2() const {
  const ::mtproto::FutureSalts_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_future_salts.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::FutureSalts_Data*>(
      &::mtproto::_FutureSalts_Data_default_instance_);
}
inline ::mtproto::FutureSalts_Data* TL_future_salts::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::FutureSalts_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_future_salts.data2)
  return data2_;
}
inline ::mtproto::FutureSalts_Data* TL_future_salts::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_future_salts.data2)
  
  ::mtproto::FutureSalts_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_future_salts::set_allocated_data2(::mtproto::FutureSalts_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_future_salts.data2)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace mtproto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_schema_2etl_2etransport_2eproto__INCLUDED
