// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: schema.tl.core_types.proto

#ifndef PROTOBUF_schema_2etl_2ecore_5ftypes_2eproto__INCLUDED
#define PROTOBUF_schema_2etl_2ecore_5ftypes_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "schema.tl.crc32.pb.h"
// @@protoc_insertion_point(includes)
namespace mtproto {
class Bool;
class BoolDefaultTypeInternal;
extern BoolDefaultTypeInternal _Bool_default_instance_;
class Bool_Data;
class Bool_DataDefaultTypeInternal;
extern Bool_DataDefaultTypeInternal _Bool_Data_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class Error_Data;
class Error_DataDefaultTypeInternal;
extern Error_DataDefaultTypeInternal _Error_Data_default_instance_;
class Null;
class NullDefaultTypeInternal;
extern NullDefaultTypeInternal _Null_default_instance_;
class Null_Data;
class Null_DataDefaultTypeInternal;
extern Null_DataDefaultTypeInternal _Null_Data_default_instance_;
class TL_boolFalse;
class TL_boolFalseDefaultTypeInternal;
extern TL_boolFalseDefaultTypeInternal _TL_boolFalse_default_instance_;
class TL_boolTrue;
class TL_boolTrueDefaultTypeInternal;
extern TL_boolTrueDefaultTypeInternal _TL_boolTrue_default_instance_;
class TL_error;
class TL_errorDefaultTypeInternal;
extern TL_errorDefaultTypeInternal _TL_error_default_instance_;
class TL_null;
class TL_nullDefaultTypeInternal;
extern TL_nullDefaultTypeInternal _TL_null_default_instance_;
class TL_true;
class TL_trueDefaultTypeInternal;
extern TL_trueDefaultTypeInternal _TL_true_default_instance_;
class True;
class TrueDefaultTypeInternal;
extern TrueDefaultTypeInternal _True_default_instance_;
class True_Data;
class True_DataDefaultTypeInternal;
extern True_DataDefaultTypeInternal _True_Data_default_instance_;
}  // namespace mtproto

namespace mtproto {

namespace protobuf_schema_2etl_2ecore_5ftypes_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_schema_2etl_2ecore_5ftypes_2eproto

// ===================================================================

class Bool_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.Bool_Data) */ {
 public:
  Bool_Data();
  virtual ~Bool_Data();

  Bool_Data(const Bool_Data& from);

  inline Bool_Data& operator=(const Bool_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Bool_Data(Bool_Data&& from) noexcept
    : Bool_Data() {
    *this = ::std::move(from);
  }

  inline Bool_Data& operator=(Bool_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Bool_Data& default_instance();

  static inline const Bool_Data* internal_default_instance() {
    return reinterpret_cast<const Bool_Data*>(
               &_Bool_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Bool_Data* other);
  friend void swap(Bool_Data& a, Bool_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Bool_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  Bool_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Bool_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mtproto.Bool_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2ecore_5ftypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Bool : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.Bool) */ {
 public:
  Bool();
  virtual ~Bool();

  Bool(const Bool& from);

  inline Bool& operator=(const Bool& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Bool(Bool&& from) noexcept
    : Bool() {
    *this = ::std::move(from);
  }

  inline Bool& operator=(Bool&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Bool& default_instance();

  static inline const Bool* internal_default_instance() {
    return reinterpret_cast<const Bool*>(
               &_Bool_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Bool* other);
  friend void swap(Bool& a, Bool& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Bool* New() const PROTOBUF_FINAL { return New(NULL); }

  Bool* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Bool* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.Bool_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::Bool_Data& data2() const;
  ::mtproto::Bool_Data* mutable_data2();
  ::mtproto::Bool_Data* release_data2();
  void set_allocated_data2(::mtproto::Bool_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.Bool)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::Bool_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2ecore_5ftypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_boolFalse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_boolFalse) */ {
 public:
  TL_boolFalse();
  virtual ~TL_boolFalse();

  TL_boolFalse(const TL_boolFalse& from);

  inline TL_boolFalse& operator=(const TL_boolFalse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_boolFalse(TL_boolFalse&& from) noexcept
    : TL_boolFalse() {
    *this = ::std::move(from);
  }

  inline TL_boolFalse& operator=(TL_boolFalse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_boolFalse& default_instance();

  static inline const TL_boolFalse* internal_default_instance() {
    return reinterpret_cast<const TL_boolFalse*>(
               &_TL_boolFalse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(TL_boolFalse* other);
  friend void swap(TL_boolFalse& a, TL_boolFalse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_boolFalse* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_boolFalse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_boolFalse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.Bool_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::Bool_Data& data2() const;
  ::mtproto::Bool_Data* mutable_data2();
  ::mtproto::Bool_Data* release_data2();
  void set_allocated_data2(::mtproto::Bool_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_boolFalse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::Bool_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2ecore_5ftypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_boolTrue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_boolTrue) */ {
 public:
  TL_boolTrue();
  virtual ~TL_boolTrue();

  TL_boolTrue(const TL_boolTrue& from);

  inline TL_boolTrue& operator=(const TL_boolTrue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_boolTrue(TL_boolTrue&& from) noexcept
    : TL_boolTrue() {
    *this = ::std::move(from);
  }

  inline TL_boolTrue& operator=(TL_boolTrue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_boolTrue& default_instance();

  static inline const TL_boolTrue* internal_default_instance() {
    return reinterpret_cast<const TL_boolTrue*>(
               &_TL_boolTrue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(TL_boolTrue* other);
  friend void swap(TL_boolTrue& a, TL_boolTrue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_boolTrue* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_boolTrue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_boolTrue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.Bool_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::Bool_Data& data2() const;
  ::mtproto::Bool_Data* mutable_data2();
  ::mtproto::Bool_Data* release_data2();
  void set_allocated_data2(::mtproto::Bool_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_boolTrue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::Bool_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2ecore_5ftypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class True_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.True_Data) */ {
 public:
  True_Data();
  virtual ~True_Data();

  True_Data(const True_Data& from);

  inline True_Data& operator=(const True_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  True_Data(True_Data&& from) noexcept
    : True_Data() {
    *this = ::std::move(from);
  }

  inline True_Data& operator=(True_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const True_Data& default_instance();

  static inline const True_Data* internal_default_instance() {
    return reinterpret_cast<const True_Data*>(
               &_True_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(True_Data* other);
  friend void swap(True_Data& a, True_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline True_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  True_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(True_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mtproto.True_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2ecore_5ftypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class True : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.True) */ {
 public:
  True();
  virtual ~True();

  True(const True& from);

  inline True& operator=(const True& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  True(True&& from) noexcept
    : True() {
    *this = ::std::move(from);
  }

  inline True& operator=(True&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const True& default_instance();

  static inline const True* internal_default_instance() {
    return reinterpret_cast<const True*>(
               &_True_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(True* other);
  friend void swap(True& a, True& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline True* New() const PROTOBUF_FINAL { return New(NULL); }

  True* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(True* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.True_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::True_Data& data2() const;
  ::mtproto::True_Data* mutable_data2();
  ::mtproto::True_Data* release_data2();
  void set_allocated_data2(::mtproto::True_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.True)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::True_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2ecore_5ftypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_true : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_true) */ {
 public:
  TL_true();
  virtual ~TL_true();

  TL_true(const TL_true& from);

  inline TL_true& operator=(const TL_true& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_true(TL_true&& from) noexcept
    : TL_true() {
    *this = ::std::move(from);
  }

  inline TL_true& operator=(TL_true&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_true& default_instance();

  static inline const TL_true* internal_default_instance() {
    return reinterpret_cast<const TL_true*>(
               &_TL_true_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(TL_true* other);
  friend void swap(TL_true& a, TL_true& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_true* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_true* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_true* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.True_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::True_Data& data2() const;
  ::mtproto::True_Data* mutable_data2();
  ::mtproto::True_Data* release_data2();
  void set_allocated_data2(::mtproto::True_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_true)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::True_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2ecore_5ftypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.Error_Data) */ {
 public:
  Error_Data();
  virtual ~Error_Data();

  Error_Data(const Error_Data& from);

  inline Error_Data& operator=(const Error_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error_Data(Error_Data&& from) noexcept
    : Error_Data() {
    *this = ::std::move(from);
  }

  inline Error_Data& operator=(Error_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error_Data& default_instance();

  static inline const Error_Data* internal_default_instance() {
    return reinterpret_cast<const Error_Data*>(
               &_Error_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Error_Data* other);
  friend void swap(Error_Data& a, Error_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  Error_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string text = 2;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mtproto.Error_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2ecore_5ftypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Error* other);
  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const PROTOBUF_FINAL { return New(NULL); }

  Error* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.Error_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::Error_Data& data2() const;
  ::mtproto::Error_Data* mutable_data2();
  ::mtproto::Error_Data* release_data2();
  void set_allocated_data2(::mtproto::Error_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.Error)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::Error_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2ecore_5ftypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_error) */ {
 public:
  TL_error();
  virtual ~TL_error();

  TL_error(const TL_error& from);

  inline TL_error& operator=(const TL_error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_error(TL_error&& from) noexcept
    : TL_error() {
    *this = ::std::move(from);
  }

  inline TL_error& operator=(TL_error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_error& default_instance();

  static inline const TL_error* internal_default_instance() {
    return reinterpret_cast<const TL_error*>(
               &_TL_error_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(TL_error* other);
  friend void swap(TL_error& a, TL_error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_error* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_error* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.Error_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::Error_Data& data2() const;
  ::mtproto::Error_Data* mutable_data2();
  ::mtproto::Error_Data* release_data2();
  void set_allocated_data2(::mtproto::Error_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_error)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::Error_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2ecore_5ftypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Null_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.Null_Data) */ {
 public:
  Null_Data();
  virtual ~Null_Data();

  Null_Data(const Null_Data& from);

  inline Null_Data& operator=(const Null_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Null_Data(Null_Data&& from) noexcept
    : Null_Data() {
    *this = ::std::move(from);
  }

  inline Null_Data& operator=(Null_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Null_Data& default_instance();

  static inline const Null_Data* internal_default_instance() {
    return reinterpret_cast<const Null_Data*>(
               &_Null_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Null_Data* other);
  friend void swap(Null_Data& a, Null_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Null_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  Null_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Null_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mtproto.Null_Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2ecore_5ftypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Null : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.Null) */ {
 public:
  Null();
  virtual ~Null();

  Null(const Null& from);

  inline Null& operator=(const Null& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Null(Null&& from) noexcept
    : Null() {
    *this = ::std::move(from);
  }

  inline Null& operator=(Null&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Null& default_instance();

  static inline const Null* internal_default_instance() {
    return reinterpret_cast<const Null*>(
               &_Null_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Null* other);
  friend void swap(Null& a, Null& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Null* New() const PROTOBUF_FINAL { return New(NULL); }

  Null* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Null* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.Null_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::Null_Data& data2() const;
  ::mtproto::Null_Data* mutable_data2();
  ::mtproto::Null_Data* release_data2();
  void set_allocated_data2(::mtproto::Null_Data* data2);

  // .mtproto.TLConstructor constructor = 1;
  void clear_constructor();
  static const int kConstructorFieldNumber = 1;
  ::mtproto::TLConstructor constructor() const;
  void set_constructor(::mtproto::TLConstructor value);

  // @@protoc_insertion_point(class_scope:mtproto.Null)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::Null_Data* data2_;
  int constructor_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2ecore_5ftypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TL_null : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mtproto.TL_null) */ {
 public:
  TL_null();
  virtual ~TL_null();

  TL_null(const TL_null& from);

  inline TL_null& operator=(const TL_null& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TL_null(TL_null&& from) noexcept
    : TL_null() {
    *this = ::std::move(from);
  }

  inline TL_null& operator=(TL_null&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TL_null& default_instance();

  static inline const TL_null* internal_default_instance() {
    return reinterpret_cast<const TL_null*>(
               &_TL_null_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(TL_null* other);
  friend void swap(TL_null& a, TL_null& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TL_null* New() const PROTOBUF_FINAL { return New(NULL); }

  TL_null* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TL_null* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mtproto.Null_Data data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  const ::mtproto::Null_Data& data2() const;
  ::mtproto::Null_Data* mutable_data2();
  ::mtproto::Null_Data* release_data2();
  void set_allocated_data2(::mtproto::Null_Data* data2);

  // @@protoc_insertion_point(class_scope:mtproto.TL_null)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mtproto::Null_Data* data2_;
  mutable int _cached_size_;
  friend struct protobuf_schema_2etl_2ecore_5ftypes_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Bool_Data

// -------------------------------------------------------------------

// Bool

// .mtproto.TLConstructor constructor = 1;
inline void Bool::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor Bool::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.Bool.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void Bool::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.Bool.constructor)
}

// .mtproto.Bool_Data data2 = 2;
inline bool Bool::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void Bool::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::Bool_Data& Bool::data2() const {
  const ::mtproto::Bool_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.Bool.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::Bool_Data*>(
      &::mtproto::_Bool_Data_default_instance_);
}
inline ::mtproto::Bool_Data* Bool::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::Bool_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.Bool.data2)
  return data2_;
}
inline ::mtproto::Bool_Data* Bool::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.Bool.data2)
  
  ::mtproto::Bool_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void Bool::set_allocated_data2(::mtproto::Bool_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.Bool.data2)
}

// -------------------------------------------------------------------

// TL_boolFalse

// .mtproto.Bool_Data data2 = 2;
inline bool TL_boolFalse::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_boolFalse::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::Bool_Data& TL_boolFalse::data2() const {
  const ::mtproto::Bool_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_boolFalse.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::Bool_Data*>(
      &::mtproto::_Bool_Data_default_instance_);
}
inline ::mtproto::Bool_Data* TL_boolFalse::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::Bool_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_boolFalse.data2)
  return data2_;
}
inline ::mtproto::Bool_Data* TL_boolFalse::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_boolFalse.data2)
  
  ::mtproto::Bool_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_boolFalse::set_allocated_data2(::mtproto::Bool_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_boolFalse.data2)
}

// -------------------------------------------------------------------

// TL_boolTrue

// .mtproto.Bool_Data data2 = 2;
inline bool TL_boolTrue::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_boolTrue::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::Bool_Data& TL_boolTrue::data2() const {
  const ::mtproto::Bool_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_boolTrue.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::Bool_Data*>(
      &::mtproto::_Bool_Data_default_instance_);
}
inline ::mtproto::Bool_Data* TL_boolTrue::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::Bool_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_boolTrue.data2)
  return data2_;
}
inline ::mtproto::Bool_Data* TL_boolTrue::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_boolTrue.data2)
  
  ::mtproto::Bool_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_boolTrue::set_allocated_data2(::mtproto::Bool_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_boolTrue.data2)
}

// -------------------------------------------------------------------

// True_Data

// -------------------------------------------------------------------

// True

// .mtproto.TLConstructor constructor = 1;
inline void True::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor True::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.True.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void True::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.True.constructor)
}

// .mtproto.True_Data data2 = 2;
inline bool True::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void True::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::True_Data& True::data2() const {
  const ::mtproto::True_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.True.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::True_Data*>(
      &::mtproto::_True_Data_default_instance_);
}
inline ::mtproto::True_Data* True::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::True_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.True.data2)
  return data2_;
}
inline ::mtproto::True_Data* True::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.True.data2)
  
  ::mtproto::True_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void True::set_allocated_data2(::mtproto::True_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.True.data2)
}

// -------------------------------------------------------------------

// TL_true

// .mtproto.True_Data data2 = 2;
inline bool TL_true::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_true::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::True_Data& TL_true::data2() const {
  const ::mtproto::True_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_true.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::True_Data*>(
      &::mtproto::_True_Data_default_instance_);
}
inline ::mtproto::True_Data* TL_true::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::True_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_true.data2)
  return data2_;
}
inline ::mtproto::True_Data* TL_true::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_true.data2)
  
  ::mtproto::True_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_true::set_allocated_data2(::mtproto::True_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_true.data2)
}

// -------------------------------------------------------------------

// Error_Data

// int32 code = 1;
inline void Error_Data::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 Error_Data::code() const {
  // @@protoc_insertion_point(field_get:mtproto.Error_Data.code)
  return code_;
}
inline void Error_Data::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:mtproto.Error_Data.code)
}

// string text = 2;
inline void Error_Data::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error_Data::text() const {
  // @@protoc_insertion_point(field_get:mtproto.Error_Data.text)
  return text_.GetNoArena();
}
inline void Error_Data::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mtproto.Error_Data.text)
}
#if LANG_CXX11
inline void Error_Data::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mtproto.Error_Data.text)
}
#endif
inline void Error_Data::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mtproto.Error_Data.text)
}
inline void Error_Data::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mtproto.Error_Data.text)
}
inline ::std::string* Error_Data::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:mtproto.Error_Data.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error_Data::release_text() {
  // @@protoc_insertion_point(field_release:mtproto.Error_Data.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error_Data::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:mtproto.Error_Data.text)
}

// -------------------------------------------------------------------

// Error

// .mtproto.TLConstructor constructor = 1;
inline void Error::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor Error::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.Error.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void Error::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.Error.constructor)
}

// .mtproto.Error_Data data2 = 2;
inline bool Error::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void Error::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::Error_Data& Error::data2() const {
  const ::mtproto::Error_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.Error.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::Error_Data*>(
      &::mtproto::_Error_Data_default_instance_);
}
inline ::mtproto::Error_Data* Error::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::Error_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.Error.data2)
  return data2_;
}
inline ::mtproto::Error_Data* Error::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.Error.data2)
  
  ::mtproto::Error_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void Error::set_allocated_data2(::mtproto::Error_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.Error.data2)
}

// -------------------------------------------------------------------

// TL_error

// .mtproto.Error_Data data2 = 2;
inline bool TL_error::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_error::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::Error_Data& TL_error::data2() const {
  const ::mtproto::Error_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_error.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::Error_Data*>(
      &::mtproto::_Error_Data_default_instance_);
}
inline ::mtproto::Error_Data* TL_error::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::Error_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_error.data2)
  return data2_;
}
inline ::mtproto::Error_Data* TL_error::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_error.data2)
  
  ::mtproto::Error_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_error::set_allocated_data2(::mtproto::Error_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_error.data2)
}

// -------------------------------------------------------------------

// Null_Data

// -------------------------------------------------------------------

// Null

// .mtproto.TLConstructor constructor = 1;
inline void Null::clear_constructor() {
  constructor_ = 0;
}
inline ::mtproto::TLConstructor Null::constructor() const {
  // @@protoc_insertion_point(field_get:mtproto.Null.constructor)
  return static_cast< ::mtproto::TLConstructor >(constructor_);
}
inline void Null::set_constructor(::mtproto::TLConstructor value) {
  
  constructor_ = value;
  // @@protoc_insertion_point(field_set:mtproto.Null.constructor)
}

// .mtproto.Null_Data data2 = 2;
inline bool Null::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void Null::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::Null_Data& Null::data2() const {
  const ::mtproto::Null_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.Null.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::Null_Data*>(
      &::mtproto::_Null_Data_default_instance_);
}
inline ::mtproto::Null_Data* Null::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::Null_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.Null.data2)
  return data2_;
}
inline ::mtproto::Null_Data* Null::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.Null.data2)
  
  ::mtproto::Null_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void Null::set_allocated_data2(::mtproto::Null_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.Null.data2)
}

// -------------------------------------------------------------------

// TL_null

// .mtproto.Null_Data data2 = 2;
inline bool TL_null::has_data2() const {
  return this != internal_default_instance() && data2_ != NULL;
}
inline void TL_null::clear_data2() {
  if (GetArenaNoVirtual() == NULL && data2_ != NULL) delete data2_;
  data2_ = NULL;
}
inline const ::mtproto::Null_Data& TL_null::data2() const {
  const ::mtproto::Null_Data* p = data2_;
  // @@protoc_insertion_point(field_get:mtproto.TL_null.data2)
  return p != NULL ? *p : *reinterpret_cast<const ::mtproto::Null_Data*>(
      &::mtproto::_Null_Data_default_instance_);
}
inline ::mtproto::Null_Data* TL_null::mutable_data2() {
  
  if (data2_ == NULL) {
    data2_ = new ::mtproto::Null_Data;
  }
  // @@protoc_insertion_point(field_mutable:mtproto.TL_null.data2)
  return data2_;
}
inline ::mtproto::Null_Data* TL_null::release_data2() {
  // @@protoc_insertion_point(field_release:mtproto.TL_null.data2)
  
  ::mtproto::Null_Data* temp = data2_;
  data2_ = NULL;
  return temp;
}
inline void TL_null::set_allocated_data2(::mtproto::Null_Data* data2) {
  delete data2_;
  data2_ = data2;
  if (data2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mtproto.TL_null.data2)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace mtproto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_schema_2etl_2ecore_5ftypes_2eproto__INCLUDED
